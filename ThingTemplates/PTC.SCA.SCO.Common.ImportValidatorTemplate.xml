<?xml version="1.0" encoding="UTF-8"?>
<Entities
 build="b222"
 majorVersion="8"
 minorVersion="5"
 modelPersistenceProviderPackage="PostgresPersistenceProviderPackage"
 revision="4"
 schemaVersion="1053"
 universal="password">
    <ThingTemplates>
        <ThingTemplate
         aspect.isEditableExtensionObject="false"
         aspect.isExtension="true"
         baseThingTemplate="GenericThing"
         description="Thing Template with services used in validating parsed equipment from excel"
         documentationContent=""
         effectiveThingPackage="ConfiguredThing"
         homeMashup=""
         lastModifiedDate="2020-03-19T18:16:21.848+05:30"
         name="PTC.SCA.SCO.Common.ImportValidatorTemplate"
         projectName="PTC.SCA.SCO.Common"
         tags="PTC:sca-sco-common;PTC:factory-mv;PTC:sca-common;PTC:ThingTemplate"
         thingPackage=""
         valueStream="">
            <avatar></avatar>
            <DesignTimePermissions>
                <Create></Create>
                <Read></Read>
                <Update></Update>
                <Delete></Delete>
                <Metadata></Metadata>
            </DesignTimePermissions>
            <RunTimePermissions>
                <Permissions
                 resourceName="*">
                    <PropertyRead>
                        <Principal
                         isPermitted="true"
                         name="FactoryUsers"
                         type="Group"></Principal>
                    </PropertyRead>
                    <PropertyWrite>
                        <Principal
                         isPermitted="true"
                         name="FactoryUsers"
                         type="Group"></Principal>
                    </PropertyWrite>
                    <ServiceInvoke>
                        <Principal
                         isPermitted="true"
                         name="FactoryUsers"
                         type="Group"></Principal>
                    </ServiceInvoke>
                    <EventInvoke>
                        <Principal
                         isPermitted="true"
                         name="FactoryUsers"
                         type="Group"></Principal>
                    </EventInvoke>
                    <EventSubscribe>
                        <Principal
                         isPermitted="true"
                         name="FactoryUsers"
                         type="Group"></Principal>
                    </EventSubscribe>
                </Permissions>
            </RunTimePermissions>
            <VisibilityPermissions>
                <Visibility>
                    <Principal
                     isPermitted="true"
                     name="PTC.Factory.MachineVisibility"
                     type="Organization"></Principal>
                </Visibility>
            </VisibilityPermissions>
            <ConfigurationTableDefinitions></ConfigurationTableDefinitions>
            <ConfigurationTables></ConfigurationTables>
            <PropertyBindings></PropertyBindings>
            <RemotePropertyBindings></RemotePropertyBindings>
            <RemoteServiceBindings></RemoteServiceBindings>
            <RemoteEventBindings></RemoteEventBindings>
            <AlertConfigurations></AlertConfigurations>
            <ThingShape>
                <PropertyDefinitions></PropertyDefinitions>
                <ServiceDefinitions>
                    <ServiceDefinition
                     aspect.isAsync="false"
                     category=""
                     description="Function responsible for setting correct report value depending on equipment validation"
                     isAllowOverride="false"
                     isLocalOnly="false"
                     isOpen="false"
                     isPrivate="false"
                     name="GenerateReportForEquipment">
                        <ResultType
                         aspect.dataShape="PTC.SCA.SCO.Common.ImportExport.ReportDataShape"
                         baseType="INFOTABLE"
                         description="Filled proper values for provided operation"
                         name="result"
                         ordinal="0"></ResultType>
                        <ParameterDefinitions>
                            <FieldDefinition
                             aspect.isRequired="true"
                             baseType="STRING"
                             description="Specifies if equipment will be created, updated or it's already exists, otherwise is invalid"
                             name="operation"
                             ordinal="1"></FieldDefinition>
                        </ParameterDefinitions>
                    </ServiceDefinition>
                    <ServiceDefinition
                     aspect.isAsync="false"
                     category=""
                     description=""
                     isAllowOverride="true"
                     isLocalOnly="false"
                     isOpen="false"
                     isPrivate="false"
                     name="ValidateEquipment">
                        <ResultType
                         aspect.dataShape="PTC.SCA.SCO.Common.ImportExport.ReportDataShape"
                         baseType="INFOTABLE"
                         description=""
                         name="result"
                         ordinal="0"></ResultType>
                        <ParameterDefinitions>
                            <FieldDefinition
                             aspect.dataShape="PTC.SCA.SCO.Common.ImportExport.EquipmentGeneralInformationDataShape"
                             aspect.isRequired="true"
                             baseType="INFOTABLE"
                             description=""
                             name="equipmentInformation"
                             ordinal="1"></FieldDefinition>
                            <FieldDefinition
                             aspect.dataShape="PTC.SCA.SCO.Common.ImportExport.EquipmentGeneralInformationDataShape"
                             aspect.isRequired="true"
                             aspect.tagType="ModelTags"
                             baseType="INFOTABLE"
                             description="Information which columns containing information about equipment was parsed"
                             name="equipmentMetadata"
                             ordinal="2"></FieldDefinition>
                        </ParameterDefinitions>
                    </ServiceDefinition>
                    <ServiceDefinition
                     aspect.isAsync="false"
                     category=""
                     description=""
                     isAllowOverride="true"
                     isLocalOnly="false"
                     isOpen="false"
                     isPrivate="false"
                     name="ValidateEquipmentHierarchyTab">
                        <ResultType
                         aspect.dataShape="PTC.SCA.SCO.Common.ImportExport.ValidationResultDataShape"
                         baseType="INFOTABLE"
                         description=""
                         name="result"
                         ordinal="0"></ResultType>
                        <ParameterDefinitions>
                            <FieldDefinition
                             aspect.dataShape="PTC.SCA.SCO.Common.ImportExportDataShape"
                             aspect.isRequired="true"
                             baseType="INFOTABLE"
                             description=""
                             name="parsedInfoTable"
                             ordinal="1"></FieldDefinition>
                        </ParameterDefinitions>
                    </ServiceDefinition>
                    <ServiceDefinition
                     aspect.isAsync="false"
                     category=""
                     description=""
                     isAllowOverride="true"
                     isLocalOnly="false"
                     isOpen="false"
                     isPrivate="false"
                     name="ValidateGeneralInformationTab">
                        <ResultType
                         aspect.dataShape="PTC.SCA.SCO.Common.ImportExport.ValidationResultDataShape"
                         baseType="INFOTABLE"
                         description=""
                         name="result"
                         ordinal="0"></ResultType>
                        <ParameterDefinitions>
                            <FieldDefinition
                             aspect.dataShape="PTC.SCA.SCO.Common.ImportExportDataShape"
                             aspect.isRequired="true"
                             baseType="INFOTABLE"
                             description=""
                             name="parsedInfoTable"
                             ordinal="1"></FieldDefinition>
                            <FieldDefinition
                             aspect.defaultValue="false"
                             aspect.isRequired="false"
                             aspect.tagType="ModelTags"
                             baseType="BOOLEAN"
                             description="Decides if equipment that does not exist should be added in the validation result"
                             name="validateOnlyExistingEquipment"
                             ordinal="2"></FieldDefinition>
                        </ParameterDefinitions>
                    </ServiceDefinition>
                    <ServiceDefinition
                     aspect.isAsync="false"
                     category=""
                     description="Validate equipment information and hierarchy from parsed InfoTable"
                     isAllowOverride="true"
                     isLocalOnly="false"
                     isOpen="false"
                     isPrivate="false"
                     name="ValidateImportFile">
                        <ResultType
                         aspect.dataShape="PTC.SCA.SCO.Common.ImportExport.ValidationResultDataShape"
                         baseType="INFOTABLE"
                         description=""
                         name="result"
                         ordinal="0"></ResultType>
                        <ParameterDefinitions>
                            <FieldDefinition
                             aspect.isRequired="true"
                             baseType="STRING"
                             description="Import operation can be 'HIERARCHY' for importing hierarchy only or 'ALL' for importing equipment and it's structure"
                             name="importOperation"
                             ordinal="2"></FieldDefinition>
                            <FieldDefinition
                             aspect.dataShape="PTC.SCA.SCO.Common.ImportExportDataShape"
                             aspect.isRequired="true"
                             baseType="INFOTABLE"
                             description=""
                             name="parsedInfoTable"
                             ordinal="1"></FieldDefinition>
                        </ParameterDefinitions>
                    </ServiceDefinition>
                    <ServiceDefinition
                     aspect.isAsync="false"
                     category=""
                     description=""
                     isAllowOverride="true"
                     isLocalOnly="false"
                     isOpen="false"
                     isPrivate="false"
                     name="ValidateLocallyBoundProperty">
                        <ResultType
                         aspect.dataShape="PTC.SCA.SCO.Common.ImportExport.ReportDataShape"
                         baseType="INFOTABLE"
                         description=""
                         name="result"
                         ordinal="0"></ResultType>
                        <ParameterDefinitions>
                            <FieldDefinition
                             aspect.dataShape="PTC.SCA.SCO.Common.ImportExportDataShape"
                             aspect.isRequired="true"
                             baseType="INFOTABLE"
                             description=""
                             name="parsedInfoTable"
                             ordinal="1"></FieldDefinition>
                        </ParameterDefinitions>
                    </ServiceDefinition>
                    <ServiceDefinition
                     aspect.isAsync="false"
                     category=""
                     description=""
                     isAllowOverride="true"
                     isLocalOnly="false"
                     isOpen="false"
                     isPrivate="false"
                     name="ValidateNoneBoundProperty">
                        <ResultType
                         aspect.dataShape="PTC.SCA.SCO.Common.ImportExport.ReportDataShape"
                         baseType="INFOTABLE"
                         description=""
                         name="result"
                         ordinal="0"></ResultType>
                        <ParameterDefinitions>
                            <FieldDefinition
                             aspect.dataShape="PTC.SCA.SCO.Common.ImportExportDataShape"
                             aspect.isRequired="true"
                             baseType="INFOTABLE"
                             description=""
                             name="parsedInfoTable"
                             ordinal="1"></FieldDefinition>
                        </ParameterDefinitions>
                    </ServiceDefinition>
                    <ServiceDefinition
                     aspect.isAsync="false"
                     category=""
                     description=""
                     isAllowOverride="true"
                     isLocalOnly="false"
                     isOpen="false"
                     isPrivate="false"
                     name="ValidatePropertiesTab">
                        <ResultType
                         aspect.dataShape="PTC.SCA.SCO.Common.ImportExport.ValidationResultDataShape"
                         baseType="INFOTABLE"
                         description=""
                         name="result"
                         ordinal="0"></ResultType>
                        <ParameterDefinitions>
                            <FieldDefinition
                             aspect.dataShape="PTC.SCA.SCO.Common.ImportExportDataShape"
                             baseType="INFOTABLE"
                             description=""
                             name="parsedInfoTable"
                             ordinal="1"></FieldDefinition>
                        </ParameterDefinitions>
                    </ServiceDefinition>
                    <ServiceDefinition
                     aspect.isAsync="false"
                     category=""
                     description=""
                     isAllowOverride="true"
                     isLocalOnly="false"
                     isOpen="false"
                     isPrivate="false"
                     name="ValidateProperty">
                        <ResultType
                         aspect.dataShape="PTC.SCA.SCO.Common.ImportExport.ReportDataShape"
                         baseType="INFOTABLE"
                         description=""
                         name="result"
                         ordinal="0"></ResultType>
                        <ParameterDefinitions>
                            <FieldDefinition
                             aspect.dataShape="PTC.SCA.SCO.Common.ImportExportDataShape"
                             aspect.isRequired="true"
                             baseType="INFOTABLE"
                             description=""
                             name="parsedInfoTable"
                             ordinal="1"></FieldDefinition>
                        </ParameterDefinitions>
                    </ServiceDefinition>
                    <ServiceDefinition
                     aspect.isAsync="false"
                     category=""
                     description=""
                     isAllowOverride="true"
                     isLocalOnly="false"
                     isOpen="false"
                     isPrivate="false"
                     name="ValidateRemotelyBoundProperty">
                        <ResultType
                         aspect.dataShape="PTC.SCA.SCO.Common.ImportExport.ReportDataShape"
                         baseType="INFOTABLE"
                         description=""
                         name="result"
                         ordinal="0"></ResultType>
                        <ParameterDefinitions>
                            <FieldDefinition
                             aspect.dataShape="PTC.SCA.SCO.Common.ImportExportDataShape"
                             aspect.isRequired="true"
                             baseType="INFOTABLE"
                             description=""
                             name="parsedInfoTable"
                             ordinal="1"></FieldDefinition>
                        </ParameterDefinitions>
                    </ServiceDefinition>
                </ServiceDefinitions>
                <EventDefinitions></EventDefinitions>
                <ServiceMappings></ServiceMappings>
                <ServiceImplementations>
                    <ServiceImplementation
                     description=""
                     handlerName="Script"
                     name="GenerateReportForEquipment">
                        <ConfigurationTables>
                            <ConfigurationTable
                             description=""
                             isMultiRow="false"
                             name="Script"
                             ordinal="0">
                                <DataShape>
                                    <FieldDefinitions>
                                        <FieldDefinition
                                         baseType="STRING"
                                         description="code"
                                         name="code"
                                         ordinal="0"></FieldDefinition>
                                    </FieldDefinitions>
                                </DataShape>
                                <Rows>
                                    <Row>
                                        <code>
                                        <![CDATA[
                                        function getDefaultValues(dataShape) {
                                          var infoTableDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                            dataShapeName: dataShape
                                          })["array"];
                                        
                                          var row = {};
                                          for (var i = 1; i < infoTableDataShapeFields.length; i++) {
                                            row[infoTableDataShapeFields[i]] = 0;
                                          }
                                        
                                          return row;
                                        }
                                        
                                        var constants = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetImportExportConstants();
                                        
                                        var reportInfoTable = Resources["InfoTableFunctions"].CreateInfoTableFromDataShape({
                                          infoTableName: "reportInfoTable",
                                          dataShapeName: constants.importReportDataShape
                                        });
                                        
                                        var infoTableDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.importReportDataShape
                                        })["array"];
                                        
                                        var row = getDefaultValues(constants.importReportDataShape);
                                        
                                        var total = infoTableDataShapeFields[1];
                                        var valid = infoTableDataShapeFields[2];
                                        var invalid = infoTableDataShapeFields[3];
                                        var exists = infoTableDataShapeFields[4];
                                        var creates = infoTableDataShapeFields[5];
                                        var updates = infoTableDataShapeFields[6];
                                        
                                        row[total] = 1;
                                        if (operation === constants.creates) {
                                          row[valid] = 1;
                                          row[creates] = 1;
                                        } else if (operation === constants.exists) {
                                          row[valid] = 1;
                                          row[exists] = 1;
                                        } else if (operation === constants.updates) {
                                          row[valid] = 1;
                                          row[updates] = 1;
                                        } else {
                                          row[invalid] = 1;
                                        }
                                        
                                        reportInfoTable.AddRow(row);
                                        
                                        var result = reportInfoTable;
                                        ]]>
                                        </code>
                                    </Row>
                                </Rows>
                            </ConfigurationTable>
                        </ConfigurationTables>
                    </ServiceImplementation>
                    <ServiceImplementation
                     description=""
                     handlerName="Script"
                     name="ValidateEquipment">
                        <ConfigurationTables>
                            <ConfigurationTable
                             description=""
                             isMultiRow="false"
                             name="Script"
                             ordinal="0">
                                <DataShape>
                                    <FieldDefinitions>
                                        <FieldDefinition
                                         baseType="STRING"
                                         description="code"
                                         name="code"
                                         ordinal="0"></FieldDefinition>
                                    </FieldDefinitions>
                                </DataShape>
                                <Rows>
                                    <Row>
                                        <code>
                                        <![CDATA[
                                        /**
                                         * Function responsible for tag parsing
                                         *
                                         */
                                        function parseTags(tags) {
                                          var splitMultipleTags = function (tags, existingTagsInfoTable) {
                                            var splittedTags = tags.split(";");
                                            var correctTags = [];
                                        
                                            for (var i = 0; i < splittedTags.length; i++) {
                                              var tag = splittedTags[i];
                                              if (tag.indexOf(":") !== -1) {
                                                var valueTag = splitTagIntoVocabularyObject(tag);
                                                if (checkIfTagExists(existingTagsInfoTable, valueTag)) {
                                                  correctTags.push(valueTag);
                                                } else {
                                                  throw "Tag: " + tag + " not found";
                                                }
                                              }
                                            }
                                        
                                            return correctTags;
                                          };
                                        
                                          var splitOneTag = function (tags, existingTagsInfoTable) {
                                            if (tags.indexOf(":") !== -1) {
                                              var correctTags = [];
                                              var valueTag = splitTagIntoVocabularyObject(tags);
                                              if (checkIfTagExists(existingTagsInfoTable, valueTag)) {
                                                correctTags.push(valueTag);
                                                return correctTags;
                                              } else {
                                                throw "Tag: " + tags + " not found";
                                              }
                                            }
                                            return undefined;
                                          };
                                        
                                          var splitTagIntoVocabularyObject = function (tag) {
                                            var tagParts = tag.split(":");
                                            var valueTag = {
                                              vocabulary: tagParts[0],
                                              vocabularyTerm: tagParts[1]
                                            };
                                            return valueTag;
                                          };
                                        
                                          var checkIfTagExists = function (existingTagsInfoTable, valueTag) {
                                            var tagRow = existingTagsInfoTable.Find(valueTag);
                                            return tagRow !== null && tagRow.vocabulary === valueTag.vocabulary && tagRow.vocabularyTerm === valueTag.vocabularyTerm;
                                          };
                                        
                                          if (tags.length === 0) {
                                            return undefined;
                                          }
                                        
                                          var existingTagsInfoTable = Resources["SearchFunctions"].SearchVocabularyTerms({
                                            maxItems: undefined /* NUMBER */ ,
                                            searchExpression: "***" /* STRING */ ,
                                            names: undefined /* JSON */ ,
                                            type: "ModelTags" /* STRING */
                                          });
                                        
                                          if (tags.indexOf(";") != -1) {
                                            return splitMultipleTags(tags, existingTagsInfoTable);
                                          } else {
                                            return splitOneTag(tags, existingTagsInfoTable);
                                          }
                                        }
                                        
                                        /**
                                         * Function responsible for extracting tags from object array
                                         * @param objectArray array which contains tag objects
                                         */
                                        function extractTagsFromObjects(objectArray) {
                                          var stringArray = [];
                                          var i = objectArray.length;
                                          while (i--) {
                                            stringArray.push(objectArray[i].vocabulary + ":" + objectArray[i].vocabularyTerm);
                                          }
                                          return stringArray;
                                        }
                                        
                                        function compareTagArrays(tagsFromThing, tagsFromExcel, defaultTags) {
                                          for (var i = 0; i < tagsFromExcel.length; i++) {
                                            if (tagsFromThing.indexOf(tagsFromExcel[i]) === -1) {
                                              return false;
                                            }
                                          }
                                        
                                          for (var i = 0; i < defaultTags.length; i++) {
                                            if (tagsFromThing.indexOf(defaultTags[i]) === -1) {
                                              return false;
                                            }
                                          }
                                        
                                          for (var x = 0; x < tagsFromThing.length; x++) {
                                            if (tagsFromExcel.indexOf(tagsFromThing[x]) === -1 && defaultTags.indexOf(tagsFromThing[x]) === -1) {
                                              return false;
                                            }
                                          }
                                          return true;
                                        }
                                        
                                        function getNullSafeString(value) {
                                          return (value === null || value === undefined) ? "" : value;
                                        }
                                        
                                        function getBooleanValue(value, defaultValue) {
                                          return Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetBooleanValue({
                                            defaultValue: defaultValue /* BOOLEAN */ ,
                                            value: value /* STRING */ ,
                                            invalidValue: defaultValue /* STRING */
                                          });
                                        }
                                        
                                        /**
                                         * Gives array of OOTB tags for proper type of equipment
                                         *
                                         * @param type Type of the equipment (Site, Line or Asset)
                                         * @returns Array of OOTB tags for given type of equipment
                                         */
                                        function getDefaultTagsForType(type) {
                                          var defaultTags = [
                                            'PTC:factory-mv',
                                            'PTC:FactoryEquipmentInstance'
                                          ];
                                        
                                          if (type === constants.site) {
                                            defaultTags = defaultTags.concat(constants.siteDefaultTags);
                                          } else if (type === constants.line) {
                                            defaultTags = defaultTags.concat(constants.lineDefaultTags);
                                          } else if (type === constants.asset) {
                                            defaultTags = defaultTags.concat(constants.assetDefaultTags);
                                          }
                                        
                                          return defaultTags;
                                        }
                                        
                                        function areThingShapeDifferent(thing, parsedShapes) {
                                          var locallyImplementedShapes = thing.GetLocallyImplementedShapes();
                                        
                                          for (var i = 0; i < parsedShapes.length; i++) {
                                            var shapeToFind = {};
                                            shapeToFind[constants.name] = parsedShapes[i];
                                        
                                            var shapeRow = locallyImplementedShapes.Find(shapeToFind);
                                        
                                            if (shapeRow == null) {
                                              return true;
                                            }
                                          }
                                        
                                          return false;
                                        }
                                        
                                        function validateProject(project) {
                                          return project.length > 0 && Projects[project] != null;
                                        }
                                        
                                        function validateHomeMashup(homeMashup) {
                                          return homeMashup.length > 0 && Mashups[homeMashup] != null;
                                        }
                                        
                                        function validateValueStream(valueStream) {
                                          return valueStream.length > 0 && Things[valueStream] != null;
                                        }
                                        
                                        function isThingContextChanged(thingName, context) {
                                          var networksArray = [];
                                          try {
                                            //remove thing from the current networks
                                            var networkList =  Resources["EntityServices"].GetEntityList({
                                              type: "Network",
                                              nameMask: "",
                                              tags: undefined,
                                              maxItems: 9999
                                            });
                                            for (var i = 0; i < networkList.rows.length; i++) {
                                              var row = networkList[i];
                                              var networkName = row[constants.name];
                                              var networkEntity = Networks[networkName];
                                              if (networkEntity.IsInNetwork({name: thingName})) {
                                                networksArray.push(networkName);
                                              }
                                            }
                                          } catch (ex){
                                            logger.error("Validation process: failed while try to get the list of newworks." + ex);
                                          }
                                          var networksArrayFromImport = getImportNetworks(context);
                                          return (networksArrayFromImport.sort().toString() !== networksArray.sort().toString());
                                        }
                                        
                                        /**
                                         * Return the valid contexts for creation in the root level
                                         */
                                        function getImportNetworks(contextValue) {
                                          var contextArray = contextValue.split(",");
                                          var networksArray = [];
                                          try {
                                            var contextSettings =  Things[constants.launchPointName].GetConfigurationTable({tableName: "EquipmentContextSettings"});
                                            for (var i = 0; i < contextSettings.rows.length; i++) {
                                              var row = contextSettings[i];
                                              var contextName = row[constants.ContextName];
                                              var networkName = row[constants.Network];
                                              if (contextArray.indexOf(contextName) >= 0 && networksArray.indexOf(networkName) < 0) {
                                                networksArray.push(networkName);
                                              }
                                            }
                                          } catch (ex){
                                            logger.error("Validation process: failed while try to get the list of networks for update/creation." + ex);
                                          }
                                          return networksArray;
                                        }
                                        
                                        function isThingVisibilityUpdated(thingName, visibility) {
                                          var visibilityPermissions = [];
                                          try {
                                            var visibilityPermissionsInfoTable = Things[thingName].GetVisibilityPermissions();
                                            for (var i = 0; i < visibilityPermissionsInfoTable.length; i++) {
                                                visibilityPermissions.push(visibilityPermissionsInfoTable[i][constants.type] + '/' + visibilityPermissionsInfoTable[i][constants.name]);
                                            }
                                          } catch (ex){
                                            logger.error("Validation process: failed while try to get visibility permission on thing. " + ex);
                                          }
                                          var existingVisibility = "";
                                          if (visibilityPermissions.length > 0) {
                                            existingVisibility = visibilityPermissions.join(";");
                                          }
                                          return visibility !== existingVisibility;
                                        }
                                        
                                        function isThingRunTimePermissionsUpdated(thingName, propertyRead, propertyWrite, serviceExecute, eventExecute, eventSubscribe) {
                                          var thing = Things[thingName];
                                        
                                          propertyRead = isEmpty(propertyRead)?"":propertyRead;
                                          var propertyReadArray = propertyRead.split(";");
                                          propertyWrite = isEmpty(propertyWrite)?"":propertyWrite;
                                          var propertyWriteArray = propertyWrite.split(";");
                                          serviceExecute = isEmpty(serviceExecute)?"":serviceExecute;
                                          var serviceExecuteArray = serviceExecute.split(";");
                                          eventExecute = isEmpty(eventExecute)?"":eventExecute;
                                          var eventExecuteArray = eventExecute.split(";");
                                          eventSubscribe = isEmpty(eventSubscribe)?"":eventSubscribe;
                                          var eventSubscribeArray = eventSubscribe.split(";");
                                        
                                          var runtimePermissionsMap = getThingRunTimePermissionsMap(thingName);
                                          var existingPropertyRead = runtimePermissionsMap.hasOwnProperty("PropertyRead")?runtimePermissionsMap["PropertyRead"]:"";
                                          var existingPropertyReadArray = existingPropertyRead.split(";");
                                          var existingPropertyWrite = runtimePermissionsMap.hasOwnProperty("PropertyWrite")?runtimePermissionsMap["PropertyWrite"]:"";
                                          var existingPropertyWriteArray = existingPropertyWrite.split(";");
                                          var existingServiceExecute = runtimePermissionsMap.hasOwnProperty("ServiceInvoke")?runtimePermissionsMap["ServiceInvoke"]:"";
                                          var existingServiceExecuteArray = existingServiceExecute.split(";");
                                          var existingEventExecute = runtimePermissionsMap.hasOwnProperty("EventInvoke")?runtimePermissionsMap["EventInvoke"]:"";
                                          var existingEventExecuteArray = existingEventExecute.split(";");
                                          var existingEventSubscribe = runtimePermissionsMap.hasOwnProperty("EventSubscribe")?runtimePermissionsMap["EventSubscribe"]:"";
                                          var existingEventSubscribeArray = existingEventSubscribe.split(";");
                                        
                                          return (propertyReadArray.sort().toString() !== existingPropertyReadArray.sort().toString()) ||
                                                 (propertyWriteArray.sort().toString() !== existingPropertyWriteArray.sort().toString()) ||
                                                 (serviceExecuteArray.sort().toString() !== existingServiceExecuteArray.sort().toString()) ||
                                                 (eventExecuteArray.sort().toString() !== existingEventExecuteArray.sort().toString()) ||
                                                 (eventSubscribeArray.sort().toString() !== existingEventSubscribeArray.sort().toString());
                                        }
                                        
                                        function getThingRunTimePermissionsMap(thingName) {
                                          var permissionMap = {};
                                          var permissionsInfoTable = Things[thingName].GetRunTimePermissions();
                                          for (var i = 0; i < permissionsInfoTable.length; i++) {
                                            //we only export permissions in the thing level
                                            if (permissionsInfoTable[i][constants.resourceName] == '*') {
                                              var permissionName = permissionsInfoTable[i][constants.permissionName];
                                              var newEntry = permissionsInfoTable[i][constants.type] + '/' + permissionsInfoTable[i][constants.name] + '/' + permissionsInfoTable[i][constants.isPermitted];
                                              if (permissionMap.hasOwnProperty(permissionName)) {
                                                permissionMap[permissionName] = permissionMap[permissionName] + ';' + newEntry;
                                              } else {
                                                permissionMap[permissionName] = newEntry;
                                              }
                                            }
                                          }
                                          return permissionMap;
                                        }
                                        
                                        function isEmpty(str) {
                                            return (str === null || str === undefined || /^\s*$/.test(str));
                                        }
                                        
                                        function checkIfThingNeedsToBeUpdated(params) {
                                          var thing = Things[params.name];
                                        
                                          return (params.descriptionMetadata && thing.GetDescription() !== params.description) ||
                                            (params.displayName.length > 0 && thing.displayName !== params.displayName) ||
                                            (params.correctTags !== undefined && !params.tagsEqual) ||
                                            (validateProject(params.project) && thing.GetProjectName() !== params.project) ||
                                            (params.identifier.length > 0 && thing.GetIdentifier() !== params.identifier) ||
                                            (validateHomeMashup(params.homeMashup) && thing.GetHomeMashup() !== params.homeMashup) ||
                                            (validateValueStream(params.valueStream) && thing.GetValueStream() !== params.valueStream) ||
                                            (params.active !== null && params.thingCurrentlyActive !== params.active) ||
                                            (params.published !== null && thing.GetPublished() !== params.published) ||
                                            (params.implementedShapes.length > 0 && areThingShapeDifferent(thing, params.implementedShapes)) ||
                                            (params.context.length > 0 && isThingContextChanged(params.name, params.context)) ||
                                            isThingVisibilityUpdated(params.name, params.visibility)||
                                            isThingRunTimePermissionsUpdated(params.name, params.propertyRead, params.propertyWrite, params.serviceExecute, params.eventExecute, params.eventSubscribe);
                                        }
                                        
                                        function validateNewThing(name, template) {
                                          var validationResult;
                                          
                                          var isNameValid = Resources["PTC.Factory.CommonUtilities"].ValidateThingName({
                                            validatedName: name
                                          });
                                          if (!isNameValid) {
                                            validationResult = me.GenerateReportForEquipment({operation: constants.invalid});
                                            logger.warn("Import Validation Process: [General Information Tab] [Name: " + name + "] Invalid reason: Name is not valid");
                                            return validationResult;
                                          } else {
                                             if (isTemplateImplementShape(template, "PTC.SCA.SCO.StatusThingShape") === true){ 
                                                 var resultMessage =  Things["PTC.Factory.StatusExpressionUtils"].ValidateDefaultStatusExpressionsByTemplate({templateName: template});
                                                 if (resultMessage !==  statusValidationSucessToken) {
                                                    validationResult = me.GenerateReportForEquipment({operation: constants.invalid});
                                                    logger.warn("Import Validation Process: [General Information Tab] [Name: " + name + "] Invalid reason: The default status expression are invalid in the thing template");
                                                    return validationResult;
                                                 }
                                             }
                                          }
                                        
                                          validationResult = me.GenerateReportForEquipment({
                                              operation: constants.creates
                                            });
                                        
                                          return validationResult;
                                        }
                                        
                                        function isTemplateImplementShape(template, thingShape) {
                                          var thingShapes = Resources["InfoTableFunctions"].CreateInfoTableFromDataShape({
                                              infoTableName: "infoTable",
                                              dataShapeName: "GenericStringList"
                                          });
                                          thingShapes.AddRow({item: thingShape});
                                          var isImplementingShape = Resources["PTC.Factory.CommonUtilities"].IsImplementingAllShapes({
                                            thingShapes: thingShapes,
                                            thingTemplateName: template
                                          }); 
                                          return isImplementingShape;
                                        }
                                        
                                        function isThingShapeValid(thingShape) {
                                          return ThingShapes[thingShape] != null;
                                        }
                                        
                                        function validateMultipleThingShapes(thingShapeArray) {
                                          var implementedShapes = [];
                                        
                                          thingShapeArray.forEach(function (element) {
                                            if (isThingShapeValid(element)) {
                                              implementedShapes.push(element);
                                            } else throw "Thing Shape: " + element + " not found";
                                          });
                                        
                                          return implementedShapes;
                                        }
                                        
                                        function parseImplementedShapes(shapesString) {
                                          var implementedShapes = [];
                                        
                                          if (shapesString.length === 0) {
                                            return implementedShapes;
                                          }
                                        
                                          if (shapesString.indexOf(';') > -1) {
                                            var splittedShapes = shapesString.split(';');
                                            implementedShapes = validateMultipleThingShapes(splittedShapes);
                                          } else {
                                            if (isThingShapeValid(shapesString)) {
                                              implementedShapes.push(shapesString);
                                            } else throw "Thing Shape: " + shapesString + " not found";
                                          }
                                        
                                          return implementedShapes;
                                        }
                                        
                                        /**
                                         * Returns array with property names
                                         *
                                         * @param propertyDefinitions InfoTable with property definitions
                                         */
                                        function getPropertyNamesArray(propertyDefinitions) {
                                          var excludedProperties = ['description', 'name', 'tags', 'thingTemplate'];
                                        
                                          var properties = [];
                                        
                                          for (var i = 0; i < propertyDefinitions.length; i++) {
                                            var name = propertyDefinitions[i][constants.name];
                                            if (excludedProperties.indexOf(name) === -1) {
                                              properties.push(name);
                                            }
                                          }
                                        
                                          return properties;
                                        }
                                        
                                        /**
                                         * Returns array with property names that comes from the entity
                                         *
                                         * @param entity Entity object (eg. ThingTemplates["someTemplate"])
                                         */
                                        function getInstancePropertyNames(entity) {
                                          var propertyDefinitions = entity.GetInstancePropertyDefinitions({
                                            type: undefined
                                          });
                                        
                                          return getPropertyNamesArray(propertyDefinitions);
                                        }
                                        
                                        /**
                                         * Return array with all properties that exist on Thing
                                         *
                                         * @param name Name of the thing
                                         */
                                        function getThingPropertyNames(name) {
                                          var propertyDefinitions = Things[name].GetPropertyDefinitions({
                                            category: undefined /* STRING */ ,
                                            type: undefined /* BASETYPENAME */ ,
                                            dataShape: undefined /* DATASHAPENAME */
                                          });
                                        
                                          return getPropertyNamesArray(propertyDefinitions);
                                        }
                                        
                                        /**
                                         * Checks if first array already contains any item from the second
                                         * Example:
                                         * haystack = ["item1", "item2"], arr = ["item2"] -> result = true
                                         *
                                         * @param haystack First array with items
                                         * @param arr Second array with items
                                         */
                                        function arrayContainsSamePropertyNames(haystack, arr) {
                                          return arr.some(function (v) {
                                            return haystack.indexOf(v) >= 0;
                                          });
                                        }
                                        
                                        /**
                                         * Get names array of conflicting property names
                                         */
                                        function getConflictingNamesArray(haystack, arr) {
                                          var conflicts = [];
                                        
                                          for (var i = 0; i < arr.length; i++) {
                                            if (haystack.indexOf(arr[i]) > -1) {
                                              conflicts.push(arr[i]);
                                            }
                                          }
                                        
                                          return conflicts;
                                        }
                                        
                                        /**
                                         * Get array with Thing Shape that has conflicting property names
                                         */
                                        function getConflictinThingShapesArray(properties, thingShapes) {
                                          var shapeNames = [];
                                        
                                          thingShapes.forEach(function (element) {
                                            var shapeProperties = getInstancePropertyNames(ThingShapes[element]);
                                            if (arrayContainsSamePropertyNames(properties, shapeProperties)) {
                                              shapeNames.push(element);
                                            }
                                          });
                                        
                                          return shapeNames;
                                        }
                                        
                                        /**
                                         * Checks if all Thing Shapes from list doesn't have conflicting property names
                                         *
                                         * @param thingShapes Array with Thing Shape names
                                         */
                                        function checkIfThingShapesHasSamePropertyNames(thingShapes) {
                                          var propertyNames = [];
                                        
                                          thingShapes.forEach(function (element) {
                                            var shapeProperties = getInstancePropertyNames(ThingShapes[element]);
                                            if (arrayContainsSamePropertyNames(propertyNames, shapeProperties)) {
                                              var conflicts = getConflictingNamesArray(propertyNames, shapeProperties);
                                              throw "Thing Shape: " + element + " have conflicting property: " + conflicts;
                                            } else {
                                              propertyNames = propertyNames.concat(shapeProperties);
                                            }
                                          });
                                        
                                          return false;
                                        }
                                        
                                        /**
                                         * Return array of not implemented Thing Shapes
                                         * @param thing Thing object which needs to be checked
                                         * @param shapes Array with Thing Shape names
                                         */
                                        function getNotImplementedThingShapes(thing, shapes) {
                                          var notImplemented = [];
                                        
                                          shapes.forEach(function (element) {
                                            var implementsShape = thing.ImplementsShape({
                                              thingShapeName: element
                                            });
                                            if (!implementsShape) {
                                              notImplemented.push(element);
                                            }
                                          });
                                        
                                          return notImplemented;
                                        }
                                        
                                        /**
                                         * Iterates over Thing Shape names array and returns array of property names from these Thing Shapes
                                         *
                                         * @param implementedShapes Array with Thing Shape names
                                         */
                                        function getPropertyNamesFromThingShapeArray(implementedShapes) {
                                          var propertyNamesFromThingShapes = [];
                                        
                                          implementedShapes.forEach(function (element) {
                                            var propertiesFromShape = getInstancePropertyNames(ThingShapes[element]);
                                            propertyNamesFromThingShapes = propertyNamesFromThingShapes.concat(propertiesFromShape);
                                          });
                                        
                                          return propertyNamesFromThingShapes;
                                        }
                                        
                                        var constants = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetImportExportConstants();
                                        
                                        var generalEquipmentDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.equipmentGeneralInformationDataShape
                                        })["array"];
                                        
                                        // Declare headers from Data Shape
                                        var nameHeader = generalEquipmentDataShapeFields[0];
                                        var typeHeader = generalEquipmentDataShapeFields[1];
                                        var contextHeader = generalEquipmentDataShapeFields[2];
                                        var displayNameHeader = generalEquipmentDataShapeFields[3];
                                        var descriptionHeader = generalEquipmentDataShapeFields[4];
                                        var tagsHeader = generalEquipmentDataShapeFields[5];
                                        var projectHeader = generalEquipmentDataShapeFields[6];
                                        var identifierHeader = generalEquipmentDataShapeFields[7];
                                        var homeMashupHeader = generalEquipmentDataShapeFields[8];
                                        var valueStreamHeader = generalEquipmentDataShapeFields[9];
                                        var activeHeader = generalEquipmentDataShapeFields[10];
                                        var publishedHeader = generalEquipmentDataShapeFields[11];
                                        var implementedShapesHeader = generalEquipmentDataShapeFields[12];
                                        var visibilityHeader = generalEquipmentDataShapeFields[13];
                                        var propertyReadHeader = generalEquipmentDataShapeFields[14];
                                        var propertyWriteHeader = generalEquipmentDataShapeFields[15];
                                        var serviceExecuteHeader = generalEquipmentDataShapeFields[16];
                                        var eventExecuteHeader = generalEquipmentDataShapeFields[17];
                                        var eventSubscribeHeader = generalEquipmentDataShapeFields[18];
                                        
                                        // Create variables for data from InfoTable
                                        var name = equipmentInformation[nameHeader];
                                        var type = equipmentInformation[typeHeader];
                                        var context = equipmentInformation[contextHeader];
                                        var displayName = getNullSafeString(equipmentInformation[displayNameHeader]);
                                        var description = getNullSafeString(equipmentInformation[descriptionHeader]);
                                        var tags = getNullSafeString(equipmentInformation[tagsHeader]);
                                        var project = getNullSafeString(equipmentInformation[projectHeader]);
                                        var identifier = getNullSafeString(equipmentInformation[identifierHeader]);
                                        var homeMashup = getNullSafeString(equipmentInformation[homeMashupHeader]);
                                        var baseThingTemplate = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetTemplateByEquipmentType({equipmentType:type});
                                        
                                        var valueStream = getNullSafeString(equipmentInformation[valueStreamHeader]);
                                        var active = getBooleanValue(equipmentInformation[activeHeader], true);
                                        var published = getBooleanValue(equipmentInformation[publishedHeader], false);
                                        var implementedShapes = getNullSafeString(equipmentInformation[implementedShapesHeader]);
                                        var visibility = getNullSafeString(equipmentInformation[visibilityHeader]);
                                        var propertyRead = getNullSafeString(equipmentInformation[propertyReadHeader]);
                                        var propertyWrite = getNullSafeString(equipmentInformation[propertyWriteHeader]);
                                        var serviceExecute = getNullSafeString(equipmentInformation[serviceExecuteHeader]);
                                        var eventExecute = getNullSafeString(equipmentInformation[eventExecuteHeader]);
                                        var eventSubscribe = getNullSafeString(equipmentInformation[eventSubscribeHeader]);
                                        
                                        var descriptionMetadata = equipmentMetadata[descriptionHeader];
                                        
                                        var thingExists = Resources["PTC.Factory.CommonUtilities"].DoesThingExists({
                                          thingName: name
                                        });
                                        
                                        // Flag that indicates if Thing is currently disabled
                                        var thingCurrentlyActive = true;
                                        
                                        // Temporary enable Thing for validation and import logic
                                        if (thingExists && !Things[name].IsEnabled()) {
                                          Things[name].EnableThing();
                                          Things[name].RestartThing();
                                          thingCurrentlyActive = false;
                                        }
                                        
                                        //token message for status expression validation on template
                                        var currentUserLanguage = Resources["CurrentSessionInfo"].GetCurrentUserLanguage();
                                        var statusValidationSucessToken = Resources["RuntimeLocalizationFunctions"].GetEffectiveTokenForLanguage({
                                              language: currentUserLanguage,
                                              token: "PTC.SCA.SCO.Status.ValidationSuccessful"
                                        });
                                        
                                        var isInformationIncorrect = false;
                                        
                                        if (baseThingTemplate === "" || ThingTemplates[baseThingTemplate] === null) {
                                          logger.warn("Import Validation Process: [General Information Tab] [Name: " + name + "] Invalid reason: baseThingTemplate [" + baseThingTemplate + "] is invalid");
                                          isInformationIncorrect = true;
                                        }
                                        
                                        if (project.length > 0 && !validateProject(project)) {
                                          logger.warn("Import Validation Process: [General Information Tab] [Name: " + name + "] Invalid reason: Project does not exist");
                                          isInformationIncorrect = true;
                                        }
                                        
                                        if (homeMashup.length > 0 && !validateHomeMashup(homeMashup)) {
                                          logger.warn("Import Validation Process: [General Information Tab] [Name: " + name + "] Invalid reason: Home Mashup does not exist");
                                          isInformationIncorrect = true;
                                        }
                                        
                                        if (!thingExists && validateValueStream(valueStream)) {
                                          logger.warn("Import Validation Process: [General Information Tab] [Name: " + name + "] Warning: Thing " + valueStream + " already exist");
                                        }
                                        
                                        try {
                                          implementedShapes = parseImplementedShapes(implementedShapes);
                                        
                                          if (!checkIfThingShapesHasSamePropertyNames(implementedShapes)) {
                                            if (thingExists) {
                                              var thingProperties = getThingPropertyNames(name);
                                        
                                              var notImplementedShapes = getNotImplementedThingShapes(Things[name], implementedShapes);
                                              var propertyNamesFromThingShapes = getPropertyNamesFromThingShapeArray(notImplementedShapes);
                                        
                                              if (arrayContainsSamePropertyNames(thingProperties, propertyNamesFromThingShapes)) {
                                                var conflictingThingShapes = getConflictinThingShapesArray(thingProperties, notImplementedShapes);
                                                var conflictingPropertyNames = getConflictingNamesArray(thingProperties, propertyNamesFromThingShapes);
                                                logger.warn("Import Validation Process: [General Information Tab] [Name: " + name + "] Invalid reason: Thing Shape: " + conflictingThingShapes + " have conflicting property names: " + conflictingPropertyNames);
                                                isInformationIncorrect = true;
                                              }
                                            } else {
                                              var thingProperties = getInstancePropertyNames(ThingTemplates[baseThingTemplate]);
                                              var propertyNamesFromThingShapes = getPropertyNamesFromThingShapeArray(implementedShapes);
                                        
                                              if (arrayContainsSamePropertyNames(thingProperties, propertyNamesFromThingShapes)) {
                                                var conflictingThingShapes = getConflictinThingShapesArray(thingProperties, implementedShapes);
                                                var conflictingPropertyNames = getConflictingNamesArray(thingProperties, propertyNamesFromThingShapes);
                                                logger.warn("Import Validation Process: [General Information Tab] [Name: " + name + "] Invalid reason: Thing Shape: " + conflictingThingShapes + " have conflicting property names: " + conflictingPropertyNames);
                                                isInformationIncorrect = true;
                                              }
                                            }
                                          }
                                        } catch (error) {
                                          logger.warn("Import Validation Process: [General Information Tab] [Name: " + name + "] Invalid reason: " + error);
                                          isInformationIncorrect = true;
                                        }
                                        
                                        try {
                                          var correctTags = parseTags(tags);
                                        } catch (error) {
                                          logger.warn("Import Validation Process: [General Information Tab] [Name: " + name + "] Invalid reason: " + error);
                                          isInformationIncorrect = true;
                                        }
                                        
                                        var validationResult;
                                        
                                        if (isInformationIncorrect) {
                                          var validationResult = me.GenerateReportForEquipment({
                                            operation: constants.invalid
                                          });
                                        } else {
                                        
                                          if (thingExists) {
                                            if (baseThingTemplate.length > 0 && Things[name].thingTemplate !== baseThingTemplate) {
                                              var validationResult = me.GenerateReportForEquipment({
                                                operation: constants.invalid
                                              });
                                        
                                              logger.warn("Import Validation Process: [General Information Tab] [Name: " + name + "] Invalid reason: Thing Template on Thing is different that in file");
                                            } else {
                                              var tagsEqual;
                                        
                                              // Compare tags from Thing with parsed
                                              if (correctTags !== undefined) {
                                                // Get tags from things and split it by semi colons
                                                var tagFromThing = Things[name].GetTags().toString().split(';');
                                        
                                                // Change object array into string array containing tags from file
                                                var tagArrayFromObject = extractTagsFromObjects(correctTags);
                                        
                                                // Get OOTB tags for equipment type
                                                var defaultTags = getDefaultTagsForType(type);
                                        
                                                // Compare array tags from Thing and from file
                                                tagsEqual = compareTagArrays(tagFromThing, tagArrayFromObject, defaultTags);
                                              }
                                        
                                              var params = {
                                                name: name,
                                                displayName: displayName,
                                                description: description,
                                                descriptionMetadata: descriptionMetadata,
                                                correctTags: correctTags,
                                                tagsEqual: tagsEqual,
                                                project: project,
                                                identifier: identifier,
                                                homeMashup: homeMashup,
                                                valueStream: valueStream,
                                                active: active,
                                                thingCurrentlyActive: thingCurrentlyActive,
                                                published: published,
                                                implementedShapes: implementedShapes,
                                                context: context,
                                                visibility: visibility,
                                                propertyRead: propertyRead,
                                                propertyWrite: propertyWrite,
                                                serviceExecute: serviceExecute,
                                                eventExecute: eventExecute,
                                                eventSubscribe: eventSubscribe
                                              };
                                              var thingNeedsToBeUpdated = checkIfThingNeedsToBeUpdated(params);
                                        
                                              if (thingNeedsToBeUpdated) {
                                                validationResult = me.GenerateReportForEquipment({
                                                  operation: constants.updates
                                                });
                                              } else {
                                                validationResult = me.GenerateReportForEquipment({
                                                  operation: constants.exists
                                                });
                                              }
                                            }
                                          } else {
                                            validationResult = validateNewThing(name, baseThingTemplate);
                                          }
                                        }
                                        
                                        var result = validationResult;
                                        ]]>
                                        </code>
                                    </Row>
                                </Rows>
                            </ConfigurationTable>
                        </ConfigurationTables>
                    </ServiceImplementation>
                    <ServiceImplementation
                     description=""
                     handlerName="Script"
                     name="ValidateEquipmentHierarchyTab">
                        <ConfigurationTables>
                            <ConfigurationTable
                             description=""
                             isMultiRow="false"
                             name="Script"
                             ordinal="0">
                                <DataShape>
                                    <FieldDefinitions>
                                        <FieldDefinition
                                         baseType="STRING"
                                         description="code"
                                         name="code"
                                         ordinal="0"></FieldDefinition>
                                    </FieldDefinitions>
                                </DataShape>
                                <Rows>
                                    <Row>
                                        <code>
                                        <![CDATA[
                                        /**
                                         * Checks for invalid relationships in given hierarchy InfoTable
                                         * @returns InfoTable with parsed equipment relationships that cannot be created
                                         */
                                        function getInvalidRelationships() {
                                          var invalidInfoTable = Resources["InfoTableFunctions"].CreateInfoTableFromDataShape({
                                            infoTableName: "invalidInfoTable",
                                            dataShapeName: constants.equipmentHierarchyDataShape
                                          });
                                        
                                          var addRowToInvalidInfoTable = function (name, parent, context) {
                                            var newRow = {
                                              name: name,
                                              parent: parent,
                                              context: context
                                            };
                                            invalidInfoTable.AddRow(newRow);
                                          };
                                        
                                          for (var i = 0; i < equipmentHierarchyInfoTable.rows.length; i++) {
                                            var row = equipmentHierarchyInfoTable.getRow(i);
                                            var rowNum = i + 2;
                                        
                                            var name = row[nameHeader];
                                            var parent = isEmpty(row[parentHeader])? "": row[parentHeader];
                                            var context = row[contextHeader];
                                            
                                            //validate empty name
                                            if (isEmpty(name)) {
                                        	  addRowToInvalidInfoTable(name, parent, context);
                                              logger.warn("Import Validation Process: [Equipment Structure Tab] [Row number: " + rowNum + "] Invalid reason: Name is required");
                                              continue;
                                            }
                                            
                                            //validate if it exists in the validated general infomatio table
                                            var childRowInGeneralInfo = findRowInGeneralInfoTab(name, context, rowNum);
                                            if (childRowInGeneralInfo === null) {
                                              addRowToInvalidInfoTable(name, parent, context);
                                              continue;
                                            }
                                            var childType = childRowInGeneralInfo[typeHeader];
                                         
                                            var parentType = "";
                                            if (!!parent) {
                                              // validate if it exists in the validated general infomatio table
                                              var parentRowInGeneralInfo = findRowInGeneralInfoTab(parent, context, rowNum);
                                              if (parentRowInGeneralInfo === null) {
                                                addRowToInvalidInfoTable(name, parent, context);
                                                continue;
                                              }
                                              parentType = parentRowInGeneralInfo[typeHeader];
                                        
                                              // validate the cycle relationship in equipment structure tab
                                              var valueRelationship = {
                                                name: parent,
                                                parent: name,
                                                conetxt: context
                                              };
                                              var findRow = equipmentHierarchyInfoTable.Find(valueRelationship);
                                              var valueCycle = {
                                                name: name,
                                                parent: parent,
                                                conetxt: context
                                              };
                                              var cycleRecord = invalidInfoTable.Find(valueCycle);
                                              if (findRow !== null && cycleRecord === null &&  parent !== name) {
                                                addRowToInvalidInfoTable(parent, name, context);
                                                logger.warn("Import Validation Process: [Equipment Structure Tab] [Row number: " + rowNum + "] [Name: " + name + "][Parent: " + parent + "] Invalid reason: The parent-child relationship will cause a cycle loop in the relationship list.");
                                                continue;
                                              }
                                            }
                                            
                                            // validate the relationship rules: non-existed, disabled, not allow manayTomany
                                            var relationshipRow = getRelationshipInfo(parentType, childType, context);
                                            if (relationshipRow === null) {
                                              addRowToInvalidInfoTable(name, parent, context);
                                              logger.warn("Import Validation Process: [Equipment Structure Tab] [Row number: " + rowNum + "] Invalid reason: The relationship (" + parent + ":" + name + ") is not defined in the equipment relationship table.");
                                            } else if (relationshipRow["Enabled"] === false) {
                                              addRowToInvalidInfoTable(name, parent, context);
                                              logger.warn("Import Validation Process: [Equipment Structure Tab] [Row number: " + rowNum + "] Invalid reason: The relationship (" + parent + ":" + name + ") is disabled in the equipment relationship table.");
                                            } else if (relationshipRow["ManyToManyCardinality"] === false && !!parent) {
                                              var query = {
                                                "filters": {
                                                    "filters": [{
                                                        "fieldName": nameHeader,
                                                        "type": "EQ",
                                                        "value": name
                                                      }, {
                                                        "fieldName": contextHeader,
                                                        "type": "EQ",
                                                        "value": context
                                                      }],
                                                    type:"AND"
                                                }
                                              };
                                              var queryResult = Resources["InfoTableFunctions"].Query({
                                                t: equipmentHierarchyInfoTable,
                                                query: query
                                              });
                                              if (queryResult.rows.length > 1) {
                                                addRowToInvalidInfoTable(name, parent, context);
                                                logger.warn("Import Validation Process:  [Equipment Structure Tab] [Row number: " + rowNum + "] Invalid reason: The relationship (" + parent + ":" + name + ") is not allowed for many to many relationship.");
                                              }
                                            }
                                          }
                                          return invalidInfoTable;
                                        }
                                        
                                        function createReportTableWithDefaultValues(dataShape) {
                                          var infoTableDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                            dataShapeName: dataShape
                                          })["array"];
                                        
                                          var row = {};
                                          for (var i = 1; i < infoTableDataShapeFields.length; i++) {
                                            row[infoTableDataShapeFields[i]] = 0;
                                          }
                                        
                                          var reportInfoTable = Resources["InfoTableFunctions"].CreateInfoTableFromDataShape({
                                            infoTableName: "reportInfoTable",
                                            dataShapeName: dataShape
                                          });
                                        
                                          reportInfoTable.AddRow(row);
                                        
                                          return reportInfoTable;
                                        }
                                        
                                        /**
                                         * Return if it is possible to create a new connection between new parent and child
                                         * @param existingParentType EquipmentType of existing parent equipment
                                         * @param parentType EquipmentType of new parent equipment
                                         * @param childType EquipmentType of child equipment
                                         */
                                        function isManyToManyAllowed(params) {
                                        
                                          //check if the ManyToMany is allowed for the existing relationship in system for params.existingParentType and params.childType
                                          var row = getRelationshipInfo(params.existingParentType, params.childType, params.context);
                                          var allowManyToManyFromSystem = row !== null && row["Enabled"] === true && row["ManyToManyCardinality"] === true;
                                          
                                          //check if the ManyToMany is allowed for the new relationship in import of params.parentType and params.childType
                                          var newRow = getRelationshipInfo(params.parentType, params.childType, params.context);
                                          var allowManyToManyFromImport = newRow !== null && newRow["Enabled"] === true && newRow["ManyToManyCardinality"] === true;
                                          
                                          return allowManyToManyFromSystem === true && allowManyToManyFromImport === true;
                                        }
                                        
                                        /**
                                         * Return the valid relationship infomation for the current context-parent-child
                                         * @param parentType equipment type of parent equipment
                                         * @param childType equipment type of child equipment
                                         */
                                        function getRelationshipInfo(parentType, childType, context) {
                                          var relationshipRow = null;
                                          if (isEmpty(childType) || isEmpty(context)) {
                                              return null;
                                          }
                                          if (parentType === null || parentType === undefined) {
                                             parentType = "";
                                          }
                                          
                                          var relationShipdKey = context+":"+parentType+":"+childType;
                                          if (relationshipMap.hasOwnProperty(relationShipdKey)) {
                                            relationshipRow = relationshipMap[relationShipdKey];        
                                          } else {
                                            relationshipRow = getRelationshipRowInConfigurationTable(parentType, childType, context);
                                            if (relationshipRow !== null) {
                                                relationshipMap[relationShipdKey] = {
                                                    "ManyToManyCardinality": relationshipRow["ManyToManyCardinality"],
                                                    "Enabled": relationshipRow["Enabled"]
                                                };
                                            }
                                          }
                                          return relationshipRow;
                                        }
                                        
                                        function getRelationshipRowInConfigurationTable(parentType, childType, context) {
                                          var relationshipRow = null;
                                          var isAddingToRootNode = isEmpty(parentType);
                                          var relationShipTable;
                                          if (relationShipTableMap.hasOwnProperty(context)) {
                                            relationShipTable = relationShipTableMap[context];
                                          } else {
                                            relationShipTable = getEquipmentRelationshipTableByContext(context);
                                            if (relationShipTable !== null) {
                                              relationShipTableMap[context] = relationShipTable;
                                            }
                                          }
                                          if (relationShipTable !== null) {
                                            for (var i = 0; i < relationShipTable.getRowCount(); i++) {
                                                var row = relationShipTable.getRow(i);
                                                var childTypeInRow = row["Child"];
                                                var parentTypeInRow = row["Parent"];  
                                                if (isAddingToRootNode && (childTypeInRow === childType || parentTypeInRow === childType)){
                                                   relationshipRow = row;
                                                   break;
                                                } else if (!isAddingToRootNode && childTypeInRow === childType && parentTypeInRow === parentType){
                                                   relationshipRow = row;
                                                   break;
                                                }
                                            }
                                            if (relationshipRow === null) {
                                              var equipmentObject = {
                                                parentType: parentType,
                                                childType: childType,
                                                contextName: context
                                              };
                                              var relationshipInfo = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetRelationshipInfoForDerivesFrom(equipmentObject);
                                              if (relationshipInfo !== null  && relationshipInfo.getRowCount() > 0) {
                                                 relationshipRow = relationshipInfo.getRow(0);
                                              }
                                            }
                                          }
                                          return relationshipRow;
                                        }
                                        
                                        function getEquipmentRelationshipTableByContext(context) {
                                          var relationshipTable = null;
                                          if (!isEmpty(context)) {
                                            try {
                                              contextConfigurationRow = Things[constants.launchPointName].GetContextConfigurationRowByContextName({
                                                contextName: context /* STRING */
                                              });
                                              var equipmentRelationshipTableName = contextConfigurationRow[constants.equipmentRelationshipSettings];
                                              if (Things[equipmentRelationshipTableName] !== null) {
                                                relationshipTable = Things[equipmentRelationshipTableName].GetDataTableEntries();
                                              }
                                            } catch (error) {
                                              logger.error(error);
                                            }
                                          }
                                          return relationshipTable;
                                        }
                                        
                                        /**
                                         * Function responsible for setting correct report value depending on equipment validation
                                         * @param reportInfoTable with current report data
                                         * @param infoTableDataShapeFields Array with DataShape field names
                                         * @param operation specifies if equipment will be created, updated or it's already exists
                                         * @returns InfoTable with filled proper values for provided operation
                                         */
                                        function markEquipment(reportInfoTable, infoTableDataShapeFields, operation) {
                                          var total = infoTableDataShapeFields[1];
                                          var valid = infoTableDataShapeFields[2];
                                          var invalid = infoTableDataShapeFields[3];
                                          var exists = infoTableDataShapeFields[4];
                                          var creates = infoTableDataShapeFields[5];
                                          var updates = infoTableDataShapeFields[6];
                                        
                                          reportInfoTable.getRow(0)[total]++;
                                          if (operation == constants.creates) {
                                            reportInfoTable.getRow(0)[valid]++;
                                            reportInfoTable.getRow(0)[creates]++;
                                          } else if (operation == constants.exists) {
                                            reportInfoTable.getRow(0)[valid]++;
                                            reportInfoTable.getRow(0)[exists]++;
                                          } else if (operation == constants.updates) {
                                            reportInfoTable.getRow(0)[valid]++;
                                            reportInfoTable.getRow(0)[updates]++;
                                          } else {
                                            reportInfoTable.getRow(0)[invalid]++;
                                          }
                                        
                                          return reportInfoTable;
                                        }
                                        
                                        function isEmpty(str) {
                                            return (str === null || str === undefined || /^\s*$/.test(str));
                                        }
                                        
                                        function findRowInGeneralInfoTab(thingName, contextName, rowNum) {
                                          var findRow = equipmentInformationInfoTable.Find({name: thingName});
                                          if (findRow !== null) {
                                            var contextGeneralInfo = findRow[contextGeneralInfoHeader];
                                            var contextList = contextGeneralInfo.split(",");
                                            if (contextList.indexOf(contextName) < 0 ){
                                              findRow = null;
                                            }
                                          }
                                          if (findRow === null) {
                                            var logMessage = "Import Validation Process: [Equipment Structure Tab] [Row number: " + rowNum + "] [Name: " + thingName + "] Invalid reason: The equipment does not match a valid row on the General Information tab.";
                                            logger.warn(logMessage);
                                          }
                                          return findRow;
                                        }
                                        
                                        /**
                                         * Return the valid contexts for creation
                                         */
                                        function getValidContexts() {
                                          var contexts = {};
                                          try {
                                            var contextSettings =  Things[constants.launchPointName].GetConfigurationTable({tableName: "EquipmentContextSettings"});
                                            for (var i = 0; i < contextSettings.rows.length; i++) {
                                              var row = contextSettings[i];
                                              var contextName = row[constants.ContextName];
                                              if (!contexts.hasOwnProperty(contextName)) {
                                                contexts[contextName] = row[constants.Network];
                                              }
                                            }
                                          } catch (ex){
                                            logger.error("Validation process: failed while try to get the list of context for creation." + ex);
                                          }
                                          return contexts;
                                        }
                                        
                                        var constants = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetImportExportConstants();
                                        
                                        var importExportDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.importExportDataShape
                                        })["array"];
                                        var hierarchyDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.equipmentHierarchyDataShape
                                        })["array"];
                                        var generalInformationDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.equipmentGeneralInformationDataShape
                                        })["array"];
                                        var reportDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.importReportDataShape
                                        })["array"];
                                        var validationResultDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.validationResultDataShape
                                        })["array"];
                                        
                                        // Declare headers constants
                                        var nameHeader = hierarchyDataShapeFields[0];
                                        var parentHeader = hierarchyDataShapeFields[1];
                                        var contextHeader = hierarchyDataShapeFields[2];
                                        var typeHeader = generalInformationDataShapeFields[1];
                                        var contextGeneralInfoHeader = generalInformationDataShapeFields[2];
                                        var propertyWriteHeader = generalInformationDataShapeFields[constants.propertyWrite];
                                        
                                        var hierarchyHeader = importExportDataShapeFields[1];
                                        var generalInformationHeader = importExportDataShapeFields[2];
                                        
                                        var reportHeader = validationResultDataShapeFields[0];
                                        
                                        // Create InfoTable for report and fill it with zeros
                                        var reportInfoTable = createReportTableWithDefaultValues(constants.importReportDataShape);
                                        
                                        // Create InfoTable for valid equipment
                                        var hierarchyInfoTable = Resources["InfoTableFunctions"].CreateInfoTableFromDataShape({
                                          infoTableName: "hierarchyInfoTable",
                                          dataShapeName: constants.equipmentHierarchyDataShape
                                        });
                                        
                                        // Create InfoTable for validation result
                                        var validatedInfoTable = Resources["InfoTableFunctions"].CreateInfoTableFromDataShape({
                                          infoTableName: "validatedInfoTable",
                                          dataShapeName: constants.validationResultDataShape
                                        });
                                        
                                        var relationshipMap = {};
                                        var relationShipTableMap = {};
                                        
                                        var validContexts = getValidContexts();
                                        
                                        var equipmentHierarchyInfoTable = parsedInfoTable[hierarchyHeader];
                                        var equipmentInformationInfoTable = parsedInfoTable[generalInformationHeader];
                                        
                                        if (equipmentHierarchyInfoTable === null || equipmentInformationInfoTable === null) {
                                          logger.warn("Import Validation Process: [Equipment Structure Tab] Invalid reason: Structure Tab or General Information Tab is empty");
                                        } else {
                                          var invalidInfoTable = getInvalidRelationships();
                                        
                                          for (var i = 0; i < equipmentHierarchyInfoTable.rows.length; i++) {
                                            var row = equipmentHierarchyInfoTable.getRow(i);
                                            var rowNum = i + 2;
                                        
                                            var name = row[nameHeader];
                                            var parent = isEmpty(row[parentHeader])? "": row[parentHeader];
                                            if (parent === "") {
                                              row[parentHeader] = "";
                                            }
                                            var context = row[contextHeader];
                                            
                                            //vaild empty name
                                            if (isEmpty(name)) {
                                              reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.invalid);
                                              continue;
                                            }
                                            
                                            //validate duplicated processed relationship
                                            var duplicateRow = hierarchyInfoTable.Find(row);
                                            if (duplicateRow !== null) {
                                              reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.invalid);           
                                              logger.warn("Import Validation Process: [Equipment Structure Tab] [Row number: " + rowNum + "] [Name: " + name + "][Parent: " + parent + "] Invalid reason: Row is duplicated");
                                              continue;
                                            }
                                        
                                            //validate relationship
                                            var valueRelationship = {
                                                name: name,
                                                parent: parent,
                                                context: context
                                            };
                                            var invalidRecord = invalidInfoTable.Find(valueRelationship);	
                                            if (invalidRecord !== null) {
                                              reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.invalid);
                                              continue;
                                            }
                                        
                                            var network = validContexts[context];
                                            var plantNetwork = Networks[network];
                                            var thingExists = Things[name];
                                            
                                            if (thingExists) {
                                              var isChildInRoot = plantNetwork.IsChild({start: undefined, name: name});
                                              var isChildInNetwork = plantNetwork.IsInNetwork({name: name});
                                              if (!!parent) {
                                        
                                                // Check if child is already connected to that thing
                                                var connectionExists = plantNetwork.IsChild({
                                                  start: parent,
                                                  name: name
                                                });
                                                if (connectionExists) {
                                                  reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.exists);
                                                  hierarchyInfoTable.AddRow(row);
                                                  continue;
                                                }
                                        
                                                // validate if child is in parent's subnetwork or if it's possible to connect both equipment
                                                var isInSubNetwork = plantNetwork.IsInSubNetwork({
                                                  start: name,
                                                  name: parent
                                                });
                                                if (isInSubNetwork) {
                                                  reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.invalid);
                                                  logger.warn("Import Validation Process: [Equipment Structure Tab] [Row number: " + rowNum + "] [Name: " + name + "][Parent: " + parent + "] Invalid reason: Child equipment is already in parrent subnetwork");
                                                  continue;
                                                }
                                        
                                                // Check if child is in the root or is not in the network
                                                if (isChildInRoot || !isChildInNetwork) {
                                                  reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.creates);
                                                  hierarchyInfoTable.AddRow(row);
                                                  continue;
                                                }
                                        
                                                // Check if child is already connected somewhere in network and it's not possible to connect it into another equipment (update operation)
                                                // Otherwise it should create new connection
                                                var existingParentName = plantNetwork.GetParentName({
                                                  name: name
                                                });
                                                var isManyToMany = false;
                                                if (!isEmpty(existingParentName)) {
                                                  var childRow = findRowInGeneralInfoTab(name, context);
                                                  var childType = isEmpty(childRow)? "": childRow[typeHeader];
                                                  
                                                  var parentRow = findRowInGeneralInfoTab(parent, context);
                                                  var parentType = isEmpty(parentRow)? "": parentRow[typeHeader];
                                                  
                                                  var parentTemplate =  Things[existingParentName].thingTemplate;
                                                  var parentTypeRow = Things[constants.launchPointName].GetEquipmentTypeSettingRowByThingTemplate({thingTemplate: parentTemplate});         
                                                  if (parentTypeRow.getRowCount() > 0) {            
                                                     var paramsManyToManyAllowed = {
                                                       parentType: parentType,
                                                       existingParentType: parentTypeRow.getRow(0).EquipmentType,
                                                       childType: childType,
                                                       context: context
                                                     };
                                                     isManyToMany = isManyToManyAllowed(paramsManyToManyAllowed);
                                                  }
                                                }
                                                if (isChildInNetwork && !isEmpty(existingParentName) && !isManyToMany) {
                                                  reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.updates);
                                                } else {
                                                  reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.creates);
                                                }
                                                hierarchyInfoTable.AddRow(row);
                                              } else {
                                                // Check if child is in network 
                                                if (isChildInNetwork){
                                                  if (isChildInRoot) {
                                                    reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.exists);
                                                  } else {//currently is linked to some parent
                                                    reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.updates);
                                                  }
                                                } else {
                                                  reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.creates);
                                                }
                                                hierarchyInfoTable.AddRow(row);
                                              }
                                            } else {
                                              // create the connection
                                              reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.creates);
                                              hierarchyInfoTable.AddRow(row);
                                            }
                                          }
                                        }
                                        
                                        var row = {};
                                        row[reportHeader] = reportInfoTable;
                                        row[hierarchyHeader] = hierarchyInfoTable;
                                        validatedInfoTable.AddRow(row);
                                        
                                        var result = validatedInfoTable;
                                        ]]>
                                        </code>
                                    </Row>
                                </Rows>
                            </ConfigurationTable>
                        </ConfigurationTables>
                    </ServiceImplementation>
                    <ServiceImplementation
                     description=""
                     handlerName="Script"
                     name="ValidateGeneralInformationTab">
                        <ConfigurationTables>
                            <ConfigurationTable
                             description=""
                             isMultiRow="false"
                             name="Script"
                             ordinal="0">
                                <DataShape>
                                    <FieldDefinitions>
                                        <FieldDefinition
                                         baseType="STRING"
                                         description="code"
                                         name="code"
                                         ordinal="0"></FieldDefinition>
                                    </FieldDefinitions>
                                </DataShape>
                                <Rows>
                                    <Row>
                                        <code>
                                        <![CDATA[
                                        function createReportTableWithDefaultValues(dataShape) {
                                          var infoTableDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                            dataShapeName: dataShape
                                          })["array"];
                                        
                                          var row = {};
                                          for (var i = 1; i < infoTableDataShapeFields.length; i++) {
                                            row[infoTableDataShapeFields[i]] = 0;
                                          }
                                        
                                          var report = Resources["InfoTableFunctions"].CreateInfoTableFromDataShape({
                                            infoTableName: "reportInfoTable",
                                            dataShapeName: dataShape
                                          });
                                        
                                          report.AddRow(row);
                                        
                                          return report;
                                        }
                                        
                                        function addValuesToReport(params) {
                                          var infoTableDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                            dataShapeName: params.dataShape
                                          })["array"];
                                        
                                          for (var i = 1; i < infoTableDataShapeFields.length; i++) {
                                            params.reportInfoTable.getRow(0)[infoTableDataShapeFields[i]] += params.sourceInfoTable.getRow(0)[infoTableDataShapeFields[i]];
                                          }
                                        
                                          return params.reportInfoTable;
                                        }
                                        
                                        function checkIfEquipmentResultIsValid(header, report) {
                                          var row = report.getRow(0);
                                          return row[header] === constants.isValid; // checks if Valid == 1
                                        }
                                        
                                        function isEmpty(str) {
                                            return (str === null || str === undefined || /^\s*$/.test(str));
                                        }
                                        
                                        /**
                                         * Function responsible for setting correct report value depending on equipment validation
                                         * @param reportInfoTable with current report data
                                         * @param infoTableDataShapeFields Array with DataShape field names
                                         * @param operation specifies if equipment will be created, updated or it's already exists
                                         * @returns InfoTable with filled proper values for provided operation
                                         */
                                        function markEquipment(reportInfoTable, infoTableDataShapeFields, operation) {
                                          var total = infoTableDataShapeFields[1];
                                          var valid = infoTableDataShapeFields[2];
                                          var invalid = infoTableDataShapeFields[3];
                                          var exists = infoTableDataShapeFields[4];
                                          var creates = infoTableDataShapeFields[5];
                                          var updates = infoTableDataShapeFields[6];
                                        
                                          reportInfoTable.getRow(0)[total]++;
                                          if (operation == constants.creates) {
                                            reportInfoTable.getRow(0)[valid]++;
                                            reportInfoTable.getRow(0)[creates]++;
                                          } else if (operation == constants.exists) {
                                            reportInfoTable.getRow(0)[valid]++;
                                            reportInfoTable.getRow(0)[exists]++;
                                          } else if (operation == constants.updates) {
                                            reportInfoTable.getRow(0)[valid]++;
                                            reportInfoTable.getRow(0)[updates]++;
                                          } else {
                                            reportInfoTable.getRow(0)[invalid]++;
                                          }
                                        
                                          return reportInfoTable;
                                        }
                                        
                                        function isRowDuplicate(row, validatedRows, generalEquipmentDataShapeFields) {
                                          var nameHeader = generalEquipmentDataShapeFields[0];
                                          var name = row[nameHeader];
                                        
                                          var objectToFind = {
                                            name: name
                                          };
                                          var duplicate = validatedRows.Find(objectToFind);
                                        
                                          return duplicate;
                                        }
                                        
                                        /**
                                         * Return the valid equipment types for creation in the root level
                                         */
                                        function getValidEquipmentTypesForCreation(contextValue) {
                                          if (isEmpty(contextValue)) {
                                             contextValue = constants.defaultContext;
                                          }
                                          if (validTypeMap.hasOwnProperty(contextValue)) {
                                             return validTypeMap[contextValue];
                                          }
                                          var types = {};
                                          try {
                                            var contextList = contextValue.split(",");
                                            for (var i = 0; i < contextList.length; i++) {
                                              var context = contextList[i];
                                              //childTypeInfoTable dataShape: "PTC.Resource.Factory.ListDataShape"
                                              var childTypeInfoTable =  Things["PTC.SCA.SCO.UIProvider"].GetEquipmentTypesForDropDownMenu({selectedRows: null, contextName:context});
                                              for (var j = 0; j < childTypeInfoTable.rows.length; j++) {
                                                var row = childTypeInfoTable.getRow(j);
                                                var internalKey = row["InternalKey"];
                                                var validType = internalKey.substring(0, internalKey.indexOf('|'));
                                                if (!types.hasOwnProperty(validType)) {
                                                  types[validType] = "";
                                                }
                                              }
                                            }
                                          } catch (ex){
                                            logger.error("Validation process: failed while try to get the list of types for creation." + ex);
                                          }
                                          validTypeMap[contextValue] = types;
                                          return types;
                                        }
                                        
                                        /**
                                         * Return the valid contexts for creation in the root level
                                         */
                                        function getValidContexts() {
                                          var contexts = {};
                                          try {
                                            var contextSettings =  Things[constants.launchPointName].GetConfigurationTable({tableName: "EquipmentContextSettings"});
                                            for (var i = 0; i < contextSettings.rows.length; i++) {
                                              var row = contextSettings[i];
                                              var contextName = row[constants.ContextName];
                                              if (!contexts.hasOwnProperty(contextName)) {
                                                contexts[contextName] = row[constants.Network];
                                              }
                                            }
                                          } catch (ex){
                                            logger.error("Validation process: failed while try to get the list of context for creation." + ex);
                                          }
                                          return contexts;
                                        }
                                        
                                        function validContextAndNetwork(contextValue) {
                                          var message = "";
                                          if (isEmpty(contextValue)) {
                                            return "The Context field is empty.";
                                          }
                                          var contextList = contextValue.split(",");
                                          for (var i = 0; i < contextList.length; i++) {
                                            var context = contextList[i];
                                        	var networkName = validContexts[context];
                                            if (!validContexts.hasOwnProperty(context)) {
                                        	  message = "The specified context is not defined in the EquipmentContextSettings configuration table on the launch point configuration thing (PTC.Factory.C_LaunchPointConfigurationThing_[ReleaseVersion]).";
                                              break;
                                            }
                                        
                                            if (!Networks[networkName]) {
                                              message = "The network associated to the specified context does not exist.";
                                              break;
                                            }
                                        
                                        	if (!isAdmin(currentUser) && !doesCurrentUserHaveRunTimePermissionsOnNetwork(networkName)) {
                                              message = "The current user does not have Read, Write or Service Execute permissions on the context specified for this equipment.";
                                              break;
                                            }
                                          }
                                          return message;
                                        }
                                        
                                        function isValidForMultipleContexts(type, contextValue) {
                                          if (isAssetThing(type)) {
                                            return true;
                                          } else if (!isEmpty(contextValue)) {
                                            var contextList = contextValue.split(",");
                                            if (contextList.length === 1) {
                                              return true;
                                            }
                                          }
                                          return false;
                                        }
                                        
                                        /**
                                         * Return if the type is recognized as asset thing for multiple contexts
                                         */
                                        function isAssetThing(type) {
                                          if (type === constants.asset) {
                                            return true;
                                          } else if(typeDeriveFromAssetMap.hasOwnProperty(type)) {
                                            return typeDeriveFromAssetMap[type];
                                          } else {
                                            var isAsset = isDerivesFromAsset(type);
                                            typeDeriveFromAssetMap[type] = isAsset;
                                            return isAsset;
                                          }
                                        }  
                                          
                                        function isDerivesFromAsset(type) {
                                          var isAsset = false;
                                          var typeSettings =  Things[constants.launchPointName].GetConfigurationTable({tableName: "EquipmentTypeSettings"});
                                          var typeRow = typeSettings.Find({EquipmentType: type});
                                          if (typeRow !== null) {
                                            var visitedTypes = [];
                                            visitedTypes.push(type);
                                            while (!isEmpty(typeRow[constants.DerivesFrom])) {
                                              if (typeRow[constants.DerivesFrom] === constants.asset) {
                                                isAsset = true;
                                                break;
                                              }
                                              var derivesFrom = typeRow[constants.DerivesFrom];
                                              if (visitedTypes.indexOf(derivesFrom) >=0 ){
                                                break;
                                              } else {
                                                visitedTypes.push(derivesFrom);
                                                typeRow = typeSettings.Find({EquipmentType: derivesFrom});
                                              }
                                            }
                                          }
                                          return isAsset;
                                        }
                                        
                                        /**
                                         * Return list of groups including to the user
                                         */
                                        function getUserGroups(user) {
                                          // result: INFOTABLE dataShape: "PTC.SCA.SCO.UserGroupNameListDataShape"
                                          return Things["PTC.SCA.SCO.ContextManager"].GetUserGroups({userName: user});
                                        }
                                        
                                        /**
                                         * Return if the network has an access to a permission setting for a user
                                           The Thingworx permission system works as follows: 
                                               Assume the following user/usergroup structure.
                                                        GrandGroup
                                                            -ParentGroup
                                                                -User
                                               deny will always trump grant; grant trumps inherit; and deny should supercede grant if the user belongs to multiple groups
                                         */
                                        function doesCurrentUserHaveRunTimePermissionsOnNetwork(networkName) {
                                          var network = Networks[networkName];
                                          var permissions = null;
                                          try {
                                              permissions =  network.GetRunTimePermissions();
                                          } catch (error) {
                                              logger.warn("Import Validation Process: " + error);
                                              return false;
                                          }
                                        
                                          // check the current user
                                          var grantPropertyRead = getRunTimePermissionValue(permissions, constants.User, currentUser, constants.PropertyRead);
                                          if (grantPropertyRead === 0) {
                                             return false;
                                          }
                                          var grantPropertyWrite = getRunTimePermissionValue(permissions, constants.User, currentUser, constants.PropertyWrite);
                                          if (grantPropertyWrite === 0) {
                                             return false;
                                          }
                                          var grantServiceInvoke = getRunTimePermissionValue(permissions, constants.User, currentUser, constants.ServiceInvoke);
                                          if (grantServiceInvoke === 0) {
                                             return false;
                                          }
                                        
                                          // check the user group
                                          for (var i = 0; i < currentUserGroups.rows.length; i++) {
                                            var row = currentUserGroups.getRow(i);
                                            var groupName = row[constants.UserGroupName];
                                        
                                            var groupGrantPropertyRead = getRunTimePermissionValue(permissions, constants.Group, groupName, constants.PropertyRead);
                                            if (groupGrantPropertyRead === 0 ) {
                                              return false;
                                            } else if (groupGrantPropertyRead === 1) {
                                              grantPropertyRead = groupGrantPropertyRead;
                                            }
                                        
                                            var groupGrantPropertyWrite = getRunTimePermissionValue(permissions, constants.Group, groupName, constants.PropertyWrite);
                                            if (groupGrantPropertyWrite === 0 ) {
                                              return false;
                                            } else if (groupGrantPropertyWrite === 1) {
                                              grantPropertyWrite = groupGrantPropertyWrite;
                                            }
                                        
                                            var groupGrantServiceInvoke = getRunTimePermissionValue(permissions, constants.Group, groupName, constants.ServiceInvoke);
                                            if (groupGrantServiceInvoke === 0 ) {
                                              return false;
                                            } else if (groupGrantServiceInvoke === 1) {
                                              grantServiceInvoke = groupGrantServiceInvoke;
                                            }
                                          }
                                        
                                          return (grantPropertyRead === 1 && grantPropertyWrite === 1 && grantServiceInvoke === 1);
                                        }
                                        
                                        /**
                                         * Return the run time permission:
                                           -1: useInherited, 0: deny, 1: grant
                                         */
                                        function getRunTimePermissionValue(permissions, userGroupType, userGroupName, permissionName) {
                                          var isPermitted = -1;
                                        
                                          var filter = {
                                           'name': userGroupName,
                                           'type' : userGroupType,
                                           'resourceName': '*',
                                           'permissionName': permissionName
                                          };
                                        
                                          var permission = permissions.Find(filter);
                                          if (permission !== null) {
                                            isPermitted = permission.isPermitted? 1: 0;
                                          }
                                          return isPermitted;
                                        }
                                        
                                        /**
                                         * Return if the import permission value include an access for user
                                         */
                                        function doesCurrentUserHaveImportPermissions(permissionValue) {
                                          if (isEmpty(permissionValue)) {
                                            return false;
                                          }
                                          var permissionList = permissionValue.split(";");
                                          if (permissionList.length > 0) {
                                            //validate user
                                            var expectedPermission = constants.User + "/" + currentUser + "/" + "true";
                                            if (permissionList.indexOf(expectedPermission) >=0) {
                                              return true;
                                            }
                                            //validate group
                                            for (var i = 0; i < currentUserGroups.rows.length; i++) {
                                              var groupName = currentUserGroups[i][constants.UserGroupName];
                                              expectedPermission = constants.Group + "/" + groupName + "/" + "true";
                                              if (permissionList.indexOf(expectedPermission) >=0) {
                                                return true;
                                              }
                                            } 
                                          }	
                                          return false;
                                        }
                                        
                                        function isAdmin(userName) {
                                          return Resources["PTC.Factory.CommonUtilities"].IsAdmin({userName: userName});
                                        }
                                        
                                        function validImportVisibility(visibilityValue) {
                                          if (isEmpty(visibility)) {
                                            return "";
                                          }
                                          var message = "";
                                          var visibilityList = visibilityValue.split(";");
                                          for (var i = 0; i < visibilityList.length; i++) {
                                            if (isEmpty(visibilityList[i])) {
                                              message = "The Visibility value cannot end or begin with a semicolon (;). Semicolons can only be used to separate multiple entries."; 
                                              break;
                                            }
                                        
                                            var visibilityPermissions = visibilityList[i].split("/");
                                            if (visibilityPermissions.length !== 2) {
                                              message = 'The Visibility value is using an invalid format. Visibility values must use the format "<OrganizationType>/<OrganizationName>" with multiple values separated by a semicolon. Valid organization types are "Organization" and "OrganizationalUnit". The format for an organizational unit name is "<orgName>:<unitName>".';
                                              break;
                                            }
                                        
                                            var orgType = visibilityPermissions[0];
                                            if (isEmpty(orgType)) {
                                              message = 'The Visibility value is missing the organization type. Valid organization types are "Organization" and "OrganizationalUnit".';
                                              break;
                                            } else if (!(orgType === constants.Organization || orgType === constants.OrganizationalUnit)) {
                                              message = 'The Visibility value contains an invalid organization type. Valid organization types are "Organization" and "OrganizationalUnit".';
                                              break;
                                            }
                                        
                                            var orgName = visibilityPermissions[1];
                                            if (isEmpty(orgName)) {
                                              message = 'The Visibility value is missing the organization or organizational unit name. Visibility values must use the format "<OrganizationType>/<OrganizationName>".';
                                              break;
                                            }
                                            switch (orgType) {
                                              case constants.Organization:
                                                if (Organizations[orgName]) {
                                                  if (!isAdmin(currentUser)) {
                                                     try {
                                                       Organizations[orgName].GetRunTimePermissions();
                                                     } catch (error) {
                                                       message = 'The current user does not have the Service Execute run time permission for the organization "' + orgName + '" specified in the Visibility value.';
                                                       logger.error("Import Validation Process: " + error);
                                                     }
                                                  }
                                                } else {
                                                   message = 'In the Visibility value, the specified organization name "' + orgName + '" does not exist or is not visible to the current user.';
                                                }
                                                break;
                                              case constants.OrganizationalUnit:
                                                message = validOrgUnitName(orgName);
                                                break;
                                              default:
                                                break;
                                            }
                                            if (message !== "") {
                                              break;
                                            }
                                          }
                                          return message;
                                        }
                                        
                                        function validOrgUnitName(orgUnitName) {
                                          var message = "";
                                          var unitNames = orgUnitName.split(":");
                                          if (unitNames.length !==2) {
                                            message = 'In the Visibility value, the format for an organizational unit name is "<orgName>:<unitName>".';
                                          } else if (isEmpty(unitNames[0])) {
                                            message = 'In the Visibility value, the organization name portion of the organizational unit name is empty. The format for an organizational unit name is "<orgName>:<unitName>".';
                                          } else if(isEmpty(unitNames[1])) {
                                            message = 'In the Visibility value, the unit name portion of the organizational unit name is empty. The format for an organizational unit name in a Visibility value is "<orgName>:<unitName>".';
                                          } else {
                                            var unitOrgName = unitNames[0];
                                            var unitUnitName = unitNames[1];
                                            if (Organizations[unitOrgName]) {
                                        	  try {
                                                 if (!Organizations[unitOrgName].IsInOrganization({name: unitUnitName})) {
                                                    message = 'In the Visibility value, the specified unit name "' + unitUnitName + '" does not exist in the specified organization "' + unitOrgName + '".';
                                                 }
                                               } catch (error) {
                                                 message = 'The current user does not have the Service Execute run time permission for the organization "' + unitOrgName + '" specified in the Visibility value.';
                                                 logger.error("Import Validation Process: " + error);
                                               }
                                            } else {
                                               message = 'In the Visibility value, the specified organization "' + unitOrgName + '" for the organizational unit does not exist.';
                                            }
                                         }
                                         return message;
                                        }
                                        
                                        function validImportRunTimePermissions(propertyRead, propertyWrite, serviceExecute, eventExecute, eventSubscribe) {
                                          var message = validImportRunTimePermissionValue(constants.PropertyRead, propertyRead);
                                          if (message.length > 0) {
                                            return message;
                                          } 
                                          message = validImportRunTimePermissionValue(constants.PropertyWrite, propertyWrite);
                                          if (message.length > 0) {
                                            return message;
                                          }
                                          message = validImportRunTimePermissionValue(constants.ServiceInvoke, serviceExecute);
                                          if (message.length > 0) {
                                            return message;
                                          }
                                          message = validImportRunTimePermissionValue(constants.EventInvoke, eventExecute);
                                          if (message.length > 0) {
                                            return message;
                                          }
                                          message = validImportRunTimePermissionValue(constants.EventSubscribe, eventSubscribe);
                                          if (message.length > 0) {
                                            return message;
                                          }
                                          return "";
                                        }
                                        
                                        function validImportRunTimePermissionValue(permissionName, permissionValue) {
                                          if (isEmpty(permissionValue)) {
                                              return "";
                                          }
                                          var message = "";
                                          var permissionList = permissionValue.split(";");
                                          for (var i = 0; i < permissionList.length; i++) {
                                            if (isEmpty(permissionList[i])) {
                                              message = 'The ' + permissionName + ' value cannot end or begin with a semicolon (;). Semicolons can only be used to separate multiple entries.'; 
                                              break;
                                            }
                                            var userPermission = permissionList[i].split("/");
                                            if (userPermission.length !== 3) {
                                              message = 'The value for ' + permissionName + ' is invalid. The format for each permission entry is "<userType>/<name>/<true or false>", with multiple values separated by a semicolon.';
                                              break;
                                            }
                                            var userGroupType = userPermission[0];
                                            if (isEmpty(userGroupType)) {
                                              message = 'In the ' + permissionName + ' value, the user type is empty. The format for each permission entry is "<userType>/<name>/<true or false>", with multiple values separated by a semicolon.';
                                              break;
                                            } else if (!(userGroupType === constants.User || userGroupType === constants.Group)) {
                                              message = 'In the ' + permissionName + ' value, the specified user type is invalid. Valid user types are "User" or "Group".';
                                              break;
                                            } 
                                            var userGroupName = userPermission[1];
                                            if (isEmpty(userGroupName)) {
                                              message = 'In the ' + permissionName + ' value, the user or group name is empty. The format for each permission entry is "<userType>/<name>/<true or false>", with multiple values separated by a semicolon.';
                                              break;
                                            }
                                            switch (userGroupType) {
                                              case constants.User:
                                                if (!Users[userGroupName]) {
                                                  message = 'In the ' + permissionName + ' value, the specified user name "' + userGroupName + '" does not exist or is not visible to the current user.';
                                                }
                                                break;
                                              case constants.Group:
                                                if (!Groups[userGroupName]) {
                                                  message = 'In the ' + permissionName+ ' value, the specified group name "' + userGroupName + '" does not exist or is not visible to the current user.';
                                                }
                                                break;
                                              default:
                                                break;
                                            }
                                            if (message !== "") {
                                              break;
                                            }
                                            var accessValue = userPermission[2];
                                            if (accessValue !== "true" && accessValue !== "false") {
                                              message = 'In the ' + permissionName + ' value, the permission access value must be "true" or "false".';
                                              break;
                                            }
                                          }
                                          return message;
                                        }
                                        
                                        var constants = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetImportExportConstants();
                                        
                                        var importExportDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.importExportDataShape
                                        })["array"];
                                        var generalEquipmentDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.equipmentGeneralInformationDataShape
                                        })["array"];
                                        var reportDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.importReportDataShape
                                        })["array"];
                                        var validationResultDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.validationResultDataShape
                                        })["array"];
                                        
                                        // Define constants for headers
                                        var generalInformationHeader = importExportDataShapeFields[2];
                                        var equipmentMetadataHeader = importExportDataShapeFields[4];
                                        
                                        var validHeader = reportDataShapeFields[2];
                                        var existsHeader = reportDataShapeFields[4];
                                        var updatesHeader = reportDataShapeFields[6];
                                        
                                        var nameHeader = generalEquipmentDataShapeFields[0];
                                        var typeHeader = generalEquipmentDataShapeFields[1];
                                        var contextHeader = generalEquipmentDataShapeFields[2];
                                        var visibilityHeader = generalEquipmentDataShapeFields[13];
                                        var propertyReadHeader = generalEquipmentDataShapeFields[14];
                                        var propertyWriteHeader = generalEquipmentDataShapeFields[15];
                                        var serviceExecuteHeader = generalEquipmentDataShapeFields[16];
                                        var eventExecuteHeader = generalEquipmentDataShapeFields[17];
                                        var eventSubscribeHeader = generalEquipmentDataShapeFields[18];
                                        
                                        var reportHeader = validationResultDataShapeFields[0];
                                        
                                        var reportInfoTable = createReportTableWithDefaultValues(constants.importReportDataShape);
                                        
                                        var generalInformationInfoTable = Resources["InfoTableFunctions"].CreateInfoTableFromDataShape({
                                          infoTableName: "generalInformationInfoTable",
                                          dataShapeName: constants.equipmentGeneralInformationDataShape
                                        });
                                        
                                        var validatedInfoTable = Resources["InfoTableFunctions"].CreateInfoTableFromDataShape({
                                          infoTableName: "validatedInfoTable",
                                          dataShapeName: constants.validationResultDataShape
                                        });
                                        
                                        var equipmentInformationInfoTable = parsedInfoTable[generalInformationHeader];
                                        var equipmentMetadata = parsedInfoTable[equipmentMetadataHeader][generalInformationHeader];
                                        
                                        var validTypeMap = {};
                                        
                                        var validContexts = getValidContexts();
                                        var typeDeriveFromAssetMap = {};
                                        var currentUser = Resources["CurrentSessionInfo"].GetCurrentUser();
                                        var currentUserGroups = getUserGroups(currentUser);
                                        
                                        if (equipmentInformationInfoTable === null) {
                                          logger.warn("Import Validation Process: [General Information Tab] Invalid reason: General Information Tab is empty");
                                        } else {
                                        
                                          for (var i = 0; i < equipmentInformationInfoTable.rows.length; i++) {
                                            var row = equipmentInformationInfoTable.getRow(i);
                                            var rowNum = i + 2;
                                        
                                            var name = row[nameHeader];
                                            var type = row[typeHeader];
                                            var context = row[contextHeader];
                                            var visibility = row[visibilityHeader];
                                            var propertyRead = row[propertyReadHeader];
                                            var propertyWrite = row[propertyWriteHeader];
                                            var serviceExecute = row[serviceExecuteHeader];
                                            var eventExecute = row[eventExecuteHeader];
                                            var eventSubscribe = row[eventSubscribeHeader];
                                        
                                            var duplicateRow = isRowDuplicate(row, generalInformationInfoTable, generalEquipmentDataShapeFields);
                                        
                                            // check if there is name and type and if row from file has been already validated
                                            if (isEmpty(name)|| isEmpty(type) || duplicateRow !== null) {
                                              reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.invalid);
                                        
                                              if (isEmpty(name)) {
                                                logger.warn("Import Validation Process: [General Information Tab] [Row number: " + rowNum + "] Invalid reason: Name is empty");
                                              }
                                        
                                              if (isEmpty(type)) {
                                                logger.warn("Import Validation Process: [General Information Tab] [Row number: " + rowNum + "] [Name: " + name + "] Invalid reason: Equipment Type is empty");
                                              }
                                        
                                              if (duplicateRow !== null) {
                                                logger.warn("Import Validation Process: [General Information Tab] [Row number: " + rowNum + "] [Name: " + name + "] Invalid reason: Row is duplicated");
                                              }
                                              continue;
                                            }
                                        
                                            // validate context and network
                                            var validateMessageResult = validContextAndNetwork(context);
                                            if (validateMessageResult !== "") {
                                              reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.invalid);
                                              logger.warn("Import Validation Process: [General Information Tab] [Row number: " + rowNum + "] [Name: " + name + "] Invalid reason: " + validateMessageResult);
                                              continue;
                                            }
                                        
                                            // validate the non-asset thing in multiple contexts
                                            if (!isValidForMultipleContexts(type, context)) {
                                              reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.invalid);
                                              logger.warn("Import Validation Process: [General Information Tab] [Row number: " + rowNum + "] [Name: " + name + "] Invalid reason: Multiple contexts can only be specified for Assets or equipment types that derive from Assets.");
                                              continue;
                                            }
                                        
                                            // validate visibility value
                                            validateMessageResult = validImportVisibility(visibility);
                                            if (validateMessageResult !== "") {
                                              reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.invalid);
                                              logger.warn("Import Validation Process: [General Information Tab] [Row number: " + rowNum + "] [Name: " + name + "] Invalid reason: " + validateMessageResult);
                                              continue;
                                            }
                                            
                                            // valid run time permission value
                                            validateMessageResult = validImportRunTimePermissions(propertyRead, propertyWrite, serviceExecute, eventExecute, eventSubscribe);
                                            if (validateMessageResult !== "") {
                                              reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.invalid);
                                              logger.warn("Import Validation Process: [General Information Tab] [Row number: " + rowNum + "] [Name: " + name + "] Invalid reason: " + validateMessageResult);
                                              continue;
                                            }
                                        
                                            // validate permission settings of propertyRead and propertyWrite for current user
                                            if (!isAdmin(currentUser) && !(doesCurrentUserHaveImportPermissions(propertyRead) && doesCurrentUserHaveImportPermissions(propertyWrite))) {
                                              reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.invalid);
                                              logger.warn("Import Validation Process: [General Information Tab] [Row number: " + rowNum + "] [Name: " + name + "] Invalid reason: The current user must be granted Read and Write permissions on this equipment in the 'PropertyRead' and 'PropertyWrite' fields, either explicitly for the user or for a user group to which the current user belongs.");
                                              continue;
                                            }
                                        
                                            var rowInfoTable = Resources["InfoTableFunctions"].CreateInfoTableFromDataShape({
                                              infoTableName: "rowInfoTable",
                                              dataShapeName: constants.equipmentGeneralInformationDataShape
                                            });
                                            rowInfoTable.AddRow(row);
                                        
                                            var validTypes = getValidEquipmentTypesForCreation(context);
                                            if (!validTypes.hasOwnProperty(type)) {
                                              reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.invalid);
                                              logger.warn("Import Validation Process: [General Information Tab] [Name: " + name + "] Invalid reason: type is invalid. The type is not found or is not enabled for equipment creation in " + constants.launchPointName + ". EquipmentTypeSettings or the type is not defined in the equipment relationship datatable for context of '" + context + "'.");
                                              continue;
                                            }
                                        
                                            var validateEquipmentResult = me.ValidateEquipment({
                                              equipmentInformation: rowInfoTable,
                                              equipmentMetadata: equipmentMetadata
                                            });
                                        
                                            var params = {
                                              reportInfoTable: reportInfoTable,
                                              sourceInfoTable: validateEquipmentResult,
                                              dataShape: constants.importReportDataShape
                                            };
                                            reportInfoTable = addValuesToReport(params);
                                        
                                            // Check if flag for validating only existing equipment is enabled (for importing only hierarchy)
                                            // If so, then check if equipment information is valid and if it's marked as exists or updates
                                            // If flag is set as false (or it's not passed - because it's not requiired) then check only if equipment is valid
                                            if (validateOnlyExistingEquipment &&
                                              checkIfEquipmentResultIsValid(validHeader, validateEquipmentResult) &&
                                              checkIfEquipmentResultIsValid(existsHeader, validateEquipmentResult) || checkIfEquipmentResultIsValid(updatesHeader, validateEquipmentResult)) {
                                              generalInformationInfoTable.AddRow(row);
                                            } else if (!validateOnlyExistingEquipment && checkIfEquipmentResultIsValid(validHeader, validateEquipmentResult)) {
                                              generalInformationInfoTable.AddRow(row);
                                            }
                                          }
                                        }
                                        
                                        var row = {};
                                        row[reportHeader] = reportInfoTable;
                                        row[generalInformationHeader] = generalInformationInfoTable;
                                        validatedInfoTable.AddRow(row);
                                        
                                        var result = validatedInfoTable;
                                        ]]>
                                        </code>
                                    </Row>
                                </Rows>
                            </ConfigurationTable>
                        </ConfigurationTables>
                    </ServiceImplementation>
                    <ServiceImplementation
                     description=""
                     handlerName="Script"
                     name="ValidateImportFile">
                        <ConfigurationTables>
                            <ConfigurationTable
                             description=""
                             isMultiRow="false"
                             name="Script"
                             ordinal="0">
                                <DataShape>
                                    <FieldDefinitions>
                                        <FieldDefinition
                                         baseType="STRING"
                                         description="code"
                                         name="code"
                                         ordinal="0"></FieldDefinition>
                                    </FieldDefinitions>
                                </DataShape>
                                <Rows>
                                    <Row>
                                        <code>
                                        <![CDATA[
                                        function checkIfImportProceedSuccessfully(reportInfoTable, reportDataShapeFields) {
                                          var invalidHeader = reportDataShapeFields[3];
                                        
                                          var isImportSuccessful = true;
                                        
                                          for (var i = 0; i < reportInfoTable.rows.length; i++) {
                                            var row = reportInfoTable.getRow(i);
                                        
                                            if (row[invalidHeader] > 0) {
                                              isImportSuccessful = false;
                                              break;
                                            }
                                          }
                                        
                                          return isImportSuccessful;
                                        }
                                        
                                        var constants = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetImportExportConstants();
                                        
                                        var currentUserLanguage = Resources["CurrentSessionInfo"].GetCurrentUserLanguage();
                                        logger.trace("Validation process started");
                                        
                                        /* Create InfoTable for validation process */
                                        var validatedInfoTable = Resources["InfoTableFunctions"].CreateInfoTableFromDataShape({
                                          infoTableName: "validatedInfoTable",
                                          dataShapeName: constants.validationResultDataShape
                                        });
                                        
                                        /* Create InfoTable for report for validation which will be included in validatedInfoTable */
                                        var reportInfoTable = Resources["InfoTableFunctions"].CreateInfoTableFromDataShape({
                                          infoTableName: "reportInfoTable",
                                          dataShapeName: constants.importReportDataShape
                                        });
                                        
                                        var validationResultDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.validationResultDataShape
                                        })["array"];
                                        var reportDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.importReportDataShape
                                        })["array"];
                                        
                                        var reportHeader = validationResultDataShapeFields[0];
                                        var hierarchyHeader = validationResultDataShapeFields[1];
                                        var generalInformationHeader = validationResultDataShapeFields[2];
                                        var propertiesHeader = validationResultDataShapeFields[3];
                                        
                                        var importHierarchyOnly;
                                        if (importOperation === "HIERARCHY") {
                                          importHierarchyOnly = true;
                                        } else {
                                          importHierarchyOnly = false;
                                        }
                                        
                                        /**
                                         * Run validation for General Information tab
                                         * This needs to be first, because it's important to check if equipment infomration
                                         * is valid before validating hierarchy or properties)
                                         */
                                        var generalInformation = me.ValidateGeneralInformationTab({
                                          parsedInfoTable: parsedInfoTable,
                                          validateOnlyExistingEquipment: importHierarchyOnly
                                        });
                                        
                                        /* Edit parsedInfoTable to contain only validated rows in General Information */
                                        parsedInfoTable[generalInformationHeader] = generalInformation[generalInformationHeader];
                                        
                                        /* Run validation for Hierarchy tab */
                                        var hierarchy = me.ValidateEquipmentHierarchyTab({
                                          parsedInfoTable: parsedInfoTable
                                        });
                                        
                                        if (!importHierarchyOnly) {
                                          /* Run validation for Properties tab */
                                          var properties = me.ValidatePropertiesTab({
                                            parsedInfoTable: parsedInfoTable
                                          });
                                        }
                                        
                                        var workSheetColumn = reportDataShapeFields[0];
                                        
                                        if (!importHierarchyOnly) {
                                          /* Gather report from General Information tab */
                                          var generalInformationReport = generalInformation[reportHeader].getRow(0);
                                          /* Add localization token into first column with sheet name */
                                          var generalInformationToken = Resources["RuntimeLocalizationFunctions"].GetEffectiveTokenForLanguage({
                                            language: currentUserLanguage,
                                            token: constants.generalInformationToken
                                          });
                                          generalInformationReport[workSheetColumn] = generalInformationToken;
                                        
                                          /* Gather report from Properties tab */
                                          var propertiesReport = properties[reportHeader].getRow(0);
                                          /* Add localization token into first column with sheet name */
                                          var propertiesToken = Resources["RuntimeLocalizationFunctions"].GetEffectiveTokenForLanguage({
                                            language: currentUserLanguage,
                                            token: constants.propertiesToken
                                          });
                                          propertiesReport[workSheetColumn] = propertiesToken;
                                        }
                                        
                                        /* Gather report from Hierarchy tab */
                                        var hierarchyReport = hierarchy[reportHeader].getRow(0);
                                        /* Add localization token into first column with sheet name */
                                        var equipmentHierarchyToken = Resources["RuntimeLocalizationFunctions"].GetEffectiveTokenForLanguage({
                                          language: currentUserLanguage,
                                          token: constants.equipmentHierarchyToken
                                        });
                                        hierarchyReport[workSheetColumn] = equipmentHierarchyToken;
                                        
                                        /* Add rows from each tab into report InfoTable */
                                        reportInfoTable.AddRow(hierarchyReport);
                                        if (!importHierarchyOnly) {
                                          reportInfoTable.AddRow(generalInformationReport);
                                          reportInfoTable.AddRow(propertiesReport);
                                        }
                                        
                                        /* Add columns with report and information from all tabs */
                                        var row = {};
                                        row[reportHeader] = reportInfoTable;
                                        row[hierarchyHeader] = hierarchy[hierarchyHeader];
                                        row[generalInformationHeader] = generalInformation[generalInformationHeader];
                                        if (!importHierarchyOnly) {
                                          row[propertiesHeader] = properties[propertiesHeader];
                                        }
                                        
                                        validatedInfoTable.AddRow(row);
                                        
                                        logger.trace("Validation process completed");
                                        
                                        var currentUser = Resources["CurrentSessionInfo"].GetCurrentUser();
                                        var isImportSuccessful = checkIfImportProceedSuccessfully(reportInfoTable, reportDataShapeFields);
                                        
                                        var paramsAtFinish = {
                                          user: currentUser /* STRING */ ,
                                          IsSuccessful: isImportSuccessful /* BOOLEAN */ ,
                                          Result: reportInfoTable /* INFOTABLE */
                                        };
                                        Things["PTC.SCA.SCO.Common.ImportProcessHistoryDataTable"].FinishProcess(paramsAtFinish);
                                        
                                        var result = validatedInfoTable;
                                        ]]>
                                        </code>
                                    </Row>
                                </Rows>
                            </ConfigurationTable>
                        </ConfigurationTables>
                    </ServiceImplementation>
                    <ServiceImplementation
                     description=""
                     handlerName="Script"
                     name="ValidateLocallyBoundProperty">
                        <ConfigurationTables>
                            <ConfigurationTable
                             description=""
                             isMultiRow="false"
                             name="Script"
                             ordinal="0">
                                <DataShape>
                                    <FieldDefinitions>
                                        <FieldDefinition
                                         baseType="STRING"
                                         description="code"
                                         name="code"
                                         ordinal="0"></FieldDefinition>
                                    </FieldDefinitions>
                                </DataShape>
                                <Rows>
                                    <Row>
                                        <code>
                                        <![CDATA[
                                        function getNullSafeString(value) {
                                          return (value === null || value === undefined) ? "" : value;
                                        }
                                        
                                        /**
                                         * Checks if property already exists on given Thing
                                         *
                                         * @param thingName Name of the thing that has property
                                         * @param propertyName Name of the property that needs to be checked
                                         */
                                        function checkIfPropertyExists(thingName, propertyName) {
                                          var propertyExists = false;
                                          if (propertyName && propertyName.length > 0) {
                                              propertyName = propertyName.replace(/-/mg, hyphen);
                                              propertyExists = (Things[thingName][propertyName] != null);
                                          }
                                          return propertyExists;
                                        }
                                        
                                        /**
                                         * Check what connection type is represented by given thing
                                         *
                                         * @param thing Name of the server thing
                                         * @returns String with connection type
                                         */
                                        function getConnectionType(thing) {
                                          var connectionType = constants.niTestStand;
                                        
                                          try {
                                              connectionType = Things['PTC.Factory.LaunchPointConfigurationThing'].GetRemoteConnectionSettingRowByThingName({
                                                  thingName : thing
                                              }).ConnectionType;
                                          } catch (err) {
                                              logger.warn('Import Validation Process: [Properties Tab] : Could not find remote connection type for [' + thing + ']. ' + err);
                                          }
                                          return connectionType;
                                        }
                                        
                                        /**
                                         * Checks if Binding information on property Thing is different than in file
                                         *
                                         * @param thingName Name of the Thing which contains property
                                         * @param name Name of the property
                                         * @param thing Name of the server thing
                                         * @param property Name of the property (or tag) for local binding
                                         */
                                        function isBindingDifferent(thingName, name, thing, property) {
                                          var currentBindingInfo = Things[thingName].GetLocalPropertyBinding({
                                            propertyName: name
                                          });
                                          // make sure that '-' is the correct encoding
                                          property = property.replace(/-/mg, hyphen);
                                          property = property.split(' ').join('_');
                                        
                                          return property !== currentBindingInfo.sourceName || thing !== currentBindingInfo.sourceThingName;
                                        }
                                        
                                        function validateExistingProperty(params) {
                                          var validationResult;
                                        
                                          if (params.connectionType === constants.kepServerEX) {
                                            if (checkIfPropertyExists(params.thing, params.property) || kepwareTagExistInKepserver(params.thing, params.property)) {
                                              if (isBindingDifferent(params.thingName, params.name, params.thing, params.property)) {
                                                validationResult = me.GenerateReportForEquipment({
                                                  operation: constants.updates
                                                });
                                              } else {
                                                validationResult = me.GenerateReportForEquipment({
                                                  operation: constants.exists
                                                });
                                              }
                                            } else {
                                              validationResult = me.GenerateReportForEquipment({
                                                operation: constants.invalid
                                              });
                                        
                                              logger.warn("Import Validation Process: [Properties Tab] [Equipment Name: " + params.thingName + " Name: " + params.name + "] Invalid reason: Tag does not exist in Kepserver");
                                            }
                                          } else {
                                            if (checkIfPropertyExists(params.thing, params.property)) {
                                              if (isBindingDifferent(params.thingName, params.name, params.thing, params.property)) {
                                                validationResult = me.GenerateReportForEquipment({
                                                  operation: constants.updates
                                                });
                                              } else {
                                                validationResult = me.GenerateReportForEquipment({
                                                  operation: constants.exists
                                                });
                                              }
                                            } else {
                                              validationResult = me.GenerateReportForEquipment({
                                                operation: constants.invalid
                                              });
                                        
                                              logger.warn("Import Validation Process: [Properties Tab] [Equipment Name: " + params.thingName + " Name: " + params.name + "] Invalid reason: Property does not exist on bound Thing");
                                            }
                                          }
                                        
                                          return validationResult;
                                        }
                                        
                                        function validateNewPropertyOnExistingThing(params) {
                                          var validationResult;
                                        
                                          if (params.connectionType === constants.kepServerEX) {
                                            var convertedProperty = params.property;
                                        
                                            if (checkIfPropertyExists(params.thing, params.property) || kepwareTagExistInKepserver(params.thing, params.property)) {
                                              var filterQuery = {
                                                'sourceName': convertedProperty,
                                                'sourceThingName':params.thing
                                              };
                                              var localPropertyBindings = Things[params.thingName].GetEffectiveLocalPropertyBindings();
                                              localPropertyBindings.Filter(filterQuery);
                                              // Check if property (or tag) isn't already bound to another property on same thing
                                              if (localPropertyBindings.getRowCount() != 0) {
                                                validationResult = me.GenerateReportForEquipment({
                                                  operation: constants.invalid
                                                });
                                        
                                                logger.warn("Import Validation Process: [Properties Tab] [Equipment Name: " + params.thingName + " Name: " + params.name + "] Invalid reason: Tag is already bound to another property on same Thing");
                                              } else {
                                                validationResult = me.GenerateReportForEquipment({
                                                  operation: constants.creates
                                                });
                                              }
                                            } else {
                                              validationResult = me.GenerateReportForEquipment({
                                                operation: constants.invalid
                                              });
                                        
                                              logger.warn("Import Validation Process: [Properties Tab] [Equipment Name: " + params.thingName + " Name: " + params.name + "] Invalid reason: Tag does not exist in Kepserver");
                                            }
                                          } else {
                                            if (checkIfPropertyExists(params.thing, params.property)) {
                                              validationResult = me.GenerateReportForEquipment({
                                                operation: constants.creates
                                              });
                                            } else {
                                              validationResult = me.GenerateReportForEquipment({
                                                operation: constants.invalid
                                              });
                                        
                                              logger.warn("Import Validation Process: [Properties Tab] [Equipment Name: " + params.thingName + " Name: " + params.name + "] Invalid reason: Property does not exist on bound Thing");
                                            }
                                          }
                                        
                                          return validationResult;
                                        }
                                        
                                        function validateNewPropertyOnNewThing(params) {
                                          var validationResult;
                                        
                                          var propertyInherited = isPropertyInherited(params.name, params.equipmentType);
                                          if (params.connectionType === constants.kepServerEX) {
                                            if (checkIfPropertyExists(params.thing, params.property) || kepwareTagExistInKepserver(params.thing, params.property)) {
                                              if (propertyInherited) {
                                                validationResult = me.GenerateReportForEquipment({
                                                  operation: constants.updates
                                                });
                                              } else {
                                                validationResult = me.GenerateReportForEquipment({
                                                    operation: constants.creates
                                                 });
                                              }
                                            } else {
                                              validationResult = me.GenerateReportForEquipment({
                                                operation: constants.invalid
                                              });
                                        
                                              logger.warn("Import Validation Process: [Properties Tab] [Equipment Name: " + params.thingName + " Name: " + params.name + "] Invalid reason: Tag does not exist in Kepserver");
                                            }
                                          } else {
                                            if (checkIfPropertyExists(params.thing, params.property)) {
                                              if (propertyInherited) {
                                                validationResult = me.GenerateReportForEquipment({
                                                  operation: constants.updates
                                                });
                                              } else {
                                                validationResult = me.GenerateReportForEquipment({
                                                    operation: constants.creates
                                                 });
                                              }
                                            } else {
                                              validationResult = me.GenerateReportForEquipment({
                                                operation: constants.invalid
                                              });
                                        
                                              logger.warn("Import Validation Process: [Properties Tab] [Equipment Name: " + params.thingName + " Name: " + params.name + "] Invalid reason: Property does not exist on bound Thing");
                                            }
                                          }
                                        
                                          return validationResult;
                                        }
                                        
                                        /**
                                         *
                                         * @param kepserverThingName Name of the server thing for local binding
                                         * @param kepTag Name of property (or tag) that should exist on Kepserver application
                                         */
                                        function kepwareTagExistInKepserver(kepserverThingName, kepTag) {
                                          var tagExistInKepserver = true;
                                        
                                        
                                          // Replace '-' to hyphen with correct char code
                                          kepTag = kepTag.replace(/-/mg, hyphen);
                                        
                                          // Replace '--' to '.'
                                          var tagSource = kepTag;
                                          if (kepTag.indexOf(doubleHyphen !== -1)) {
                                            tagSource = tagSource.split(doubleHyphen).join(dot);
                                          }
                                        
                                          var tagName = kepTag;
                                          if (kepTag.indexOf(hyphen !== -1)) {
                                            // Trim kepTag to obtain tagName (without hierarchy prefix)
                                            tagName = kepTag.substring(kepTag.lastIndexOf(hyphen) + 1).trim();
                                          }
                                        
                                          var path = tagSource;
                                          var lastPathOfThingName = tagSource.lastIndexOf(dot + tagName);
                                          if (lastPathOfThingName >= 0) {
                                            path = path.substring(0, lastPathOfThingName);
                                          }
                                          // Replace '_' into spaces
                                          path = path.split('_').join(' ');
                                        
                                          var findTagParams = {
                                            filter: tagName /* STRING */ ,
                                            path: path /* STRING */ ,
                                            subscribedTags: undefined /* INFOTABLE */ ,
                                            typeFilter: undefined /* STRING */ ,
                                            serverName: kepserverThingName /* STRING */ ,
                                            sourceFilter: undefined /* STRING */ ,
                                            connectionType: constants.kepServerEX /* STRING */ ,
                                            sortQuery: undefined /* QUERY */
                                          };
                                        
                                          // Query tags that exists on Kepserver application
                                          var findTag = Things["PTC.Factory.Administration.TagConfigurationUtils"].GetServerTags(findTagParams);
                                          if (findTag.length < 1) {
                                            tagExistInKepserver = false;
                                          }
                                        
                                          return tagExistInKepserver;
                                        }
                                        
                                        function isPropertyInherited(propertyName, thingType) {
                                          // result: BOOLEAN
                                          var isInherited = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].isPropertyInherited({
                                            propertyName: propertyName /* STRING */ ,
                                            equipmentType: thingType /* STRING */
                                          });
                                          return isInherited;
                                        }
                                        
                                        var constants = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetImportExportConstants();
                                        
                                        var hyphen = String.fromCharCode(45);
                                        var doubleHyphen = hyphen + hyphen;
                                        var dot = String.fromCharCode(46);
                                        
                                        var importExportDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.importExportDataShape
                                        })["array"];
                                        var generalInformationDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.equipmentGeneralInformationDataShape
                                        })["array"];
                                        var propertiesDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.equipmentPropertiesDataShape
                                        })["array"];
                                        
                                        var equipmentInformation = parsedInfoTable[importExportDataShapeFields[2]];
                                        var equipmentProperty = parsedInfoTable[importExportDataShapeFields[3]];
                                        
                                        // Define constants for headers
                                        var thingNameHeader = propertiesDataShapeFields[0];
                                        var nameHeader = propertiesDataShapeFields[1];
                                        var baseTypeHeader = propertiesDataShapeFields[5];
                                        var thingHeader = propertiesDataShapeFields[8];
                                        var propertyHeader = propertiesDataShapeFields[9];
                                        
                                        var thingName = equipmentProperty[thingNameHeader];
                                        var name = equipmentProperty[nameHeader];
                                        var baseType = equipmentProperty[baseTypeHeader];
                                        var thing = getNullSafeString(equipmentProperty[thingHeader]);
                                        var property = getNullSafeString(equipmentProperty[propertyHeader]);
                                        
                                        baseType = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].ConvertBaseTypeToFriendlyName({
                                          baseType: baseType
                                        });
                                        
                                        
                                        var equipmentRow = equipmentInformation.Find({name: thingName});
                                        var equipmentType = getNullSafeString(equipmentRow[constants.equipmentType]);
                                        
                                        var thingExists = (Things[thingName] != null);
                                        var boundThingExists = (Things[thing] != null);
                                        var validationResult;
                                        
                                        // Check if server thing or property for bounding exists
                                        if (!boundThingExists || property.length === 0) {
                                          validationResult = me.GenerateReportForEquipment({
                                            operation: constants.invalid
                                          });
                                        
                                          if (!boundThingExists) {
                                            logger.warn("Import Validation Process: [Properties Tab] [Equipment Name: " + thingName + " Name: " + name + "] Invalid reason: Thing does not exist");
                                          }
                                        
                                          if (property.length === 0) {
                                            logger.warn("Import Validation Process: [Properties Tab] [Equipment Name: " + thingName + " Name: " + name + "] Invalid reason: Property not specified");
                                          }
                                        } else {
                                          var connectionType = getConnectionType(thing);
                                        
                                          var params = {
                                            thingName: thingName,
                                            name: name,
                                            thing: thing,
                                            property: property,
                                            baseType: baseType,
                                            connectionType: connectionType,
                                            equipmentType: equipmentType
                                          };
                                        
                                          if (thingExists) {
                                            if (checkIfPropertyExists(thingName, name)) {
                                              validationResult = validateExistingProperty(params);
                                            } else {
                                              validationResult = validateNewPropertyOnExistingThing(params);
                                            }
                                          } else {
                                            validationResult = validateNewPropertyOnNewThing(params);
                                          }
                                        }
                                        
                                        var result = validationResult;
                                        ]]>
                                        </code>
                                    </Row>
                                </Rows>
                            </ConfigurationTable>
                        </ConfigurationTables>
                    </ServiceImplementation>
                    <ServiceImplementation
                     description=""
                     handlerName="Script"
                     name="ValidateNoneBoundProperty">
                        <ConfigurationTables>
                            <ConfigurationTable
                             description=""
                             isMultiRow="false"
                             name="Script"
                             ordinal="0">
                                <DataShape>
                                    <FieldDefinitions>
                                        <FieldDefinition
                                         baseType="STRING"
                                         description="code"
                                         name="code"
                                         ordinal="0"></FieldDefinition>
                                    </FieldDefinitions>
                                </DataShape>
                                <Rows>
                                    <Row>
                                        <code>
                                        <![CDATA[
                                        function getNullSafeString(value) {
                                          return (value === null || value === undefined) ? "" : value;
                                        }
                                        
                                        function isIsoDate(myDate) {
                                            var dateRegex = /^\d{4}-[0-1]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)$/;
                                            return myDate.match(dateRegex);
                                        }
                                        
                                        function getDateTimeNumber(value) {
                                          if (value == null || value === '') {
                                              return 0;
                                          }
                                          var returnValue = value;
                                          try {
                                              if (!(value instanceof Date) && typeof(value) == 'string' && isIsoDate(value)) {
                                                returnValue = parseDateISO(returnValue);
                                              }
                                              returnValue = returnValue.getTime();
                                              // ignore milliseconds
                                              returnValue = returnValue - (returnValue % 1000);
                                          } catch (ex) {
                                              logger.error("Import Validation Process : ImportNoneBoundProperty :: Could not parse datetime value : " + value + " : " + ex);
                                          }
                                          return returnValue;
                                        }
                                        
                                        function getBooleanValue(value) {
                                          return Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetBooleanValue({
                                            defaultValue: false /* BOOLEAN */ ,
                                            value: value /* STRING */ ,
                                            invalidValue: null /* STRING */
                                          });
                                        }
                                        
                                        function isBaseTypeSupported(baseType) {
                                          var supportedBaseTypes = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetImportSupportedBaseTypes()["array"];
                                        
                                          return supportedBaseTypes.indexOf(baseType) > -1;
                                        }
                                        
                                        /**
                                         * Checks if property already exists on given Thing
                                         *
                                         * @param thingName Name of the thing that has property
                                         * @param propertyName Name of the property that needs to be checked
                                         */
                                        function checkIfPropertyExists(thingName, propertyName) {
                                          var propertyExists = (Things[thingName][propertyName] != null);
                                        
                                          return propertyExists;
                                        }
                                        
                                        function isPropertyInherited(propertyName, thingType) {
                                          // result: BOOLEAN
                                          var isInherited = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].isPropertyInherited({
                                            propertyName: propertyName /* STRING */ ,
                                            equipmentType: thingType /* STRING */
                                          });
                                          return isInherited;
                                        }
                                        
                                        function validateAndParseValue(baseType, value) {
                                          baseType = baseType.toUpperCase();
                                          var empty = '';
                                        
                                          if (baseType === 'NUMBER') {
                                            var defaultNumberValue = '0';
                                            if (value == undefined || value == empty) {
                                              value = defaultNumberValue;
                                            } else {
                                              value = isNaN(parseInt(value)) ? null : Number(value);
                                            }
                                          } else if (baseType === 'DATETIME') {
                                            if (value == undefined || value == empty) {
                                              value = new Date();
                                            } else {
                                              //format YYYY-MM-DDTHH:mm:ss.sssZ
                                              if (typeof(value) == 'string' && isIsoDate(value)) {
                                                value = parseDateISO(value);
                                              } else {
                                                value = null;
                                              }
                                            }
                                          } else if (baseType === 'BOOLEAN') {
                                            value = getBooleanValue(value);
                                          } else if (baseType === 'STRING') {
                                            var defaultStringValue = "";
                                            if (value == undefined || value === empty) {
                                              value = defaultStringValue;
                                            }
                                          } else if (baseType === 'JSON') {
                                            var defaultJsonValue = {};
                                            if (value == undefined || value == empty) {
                                              value = defaultJsonValue;
                                            } else {
                                              try {
                                                value = JSON.parse(value);
                                              } catch (error) {
                                                value = null;
                                              }
                                            }
                                          } else if (baseType === 'INTEGER' || baseType === 'LONG') {
                                            var defaultIntValue = '0';
                                            if (value == undefined || value == empty) {
                                              value = defaultIntValue;
                                            } else {
                                              value = isNaN(parseInt(value)) ? null : parseInt(value);
                                            }
                                          }
                                          return value;
                                        }
                                        
                                        function compareJSON(obj1, obj2) {
                                          return Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].CompareJSONObjects({
                                            json1: obj1,
                                            json2: obj2
                                          });
                                        }
                                        
                                        function isBaseTypeDifferent(thingName, name, baseType, thingType) {
                                            baseType=baseType.toUpperCase();
                                            if (Things[thingName] !== null && checkIfPropertyExists(thingName, name)) {
                                                var propertyDefinition = Things[thingName].GetPropertyDefinition({
                                                    "name": name
                                                });
                                                return propertyDefinition.baseType !== baseType;
                                            } else if (isPropertyInherited(name, thingType)) {
                                                var templateName = thingType === constants.line ? constants.lineTemplate : constants.mfgAssetTemplate;
                                        
                                                // result: INFOTABLE dataShape: "PropertyDefinition"
                                                var propertyDefinitions = ThingTemplates[templateName].GetInstancePropertyDefinitions({
                                                    type: undefined /* STRING */
                                                });
                                        
                                                for (var i = 0; i < propertyDefinitions.length; i++) {
                                                    var propertyDefinition = propertyDefinitions[i];
                                                    if (propertyDefinition[constants.name] === name) {
                                                        return propertyDefinition.baseType !== baseType;
                                                    }
                                                }
                                            }
                                            return false;
                                        }
                                        
                                        
                                        function toIsoString(date) {
                                          return Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].ToISOString({
                                            date: date
                                          });
                                        }
                                        
                                        
                                        var constants = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetImportExportConstants();
                                        
                                        var importExportDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.importExportDataShape
                                        })["array"];
                                        var generalInformationDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.equipmentGeneralInformationDataShape
                                        })["array"];
                                        var propertiesDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.equipmentPropertiesDataShape
                                        })["array"];
                                        
                                        var equipmentInformation = parsedInfoTable[importExportDataShapeFields[2]];
                                        var equipmentProperty = parsedInfoTable[importExportDataShapeFields[3]];
                                        
                                        // Define constants for headers
                                        var thingNameHeader = propertiesDataShapeFields[0];
                                        var nameHeader = propertiesDataShapeFields[1];
                                        var valueHeader = propertiesDataShapeFields[4];
                                        var baseTypeHeader = propertiesDataShapeFields[5];
                                        var loggedHeader = propertiesDataShapeFields[6];
                                        var thingName = equipmentProperty[thingNameHeader];
                                        var name = equipmentProperty[nameHeader];
                                        var value = equipmentProperty[valueHeader];
                                        var baseType = equipmentProperty[baseTypeHeader];
                                        var logged = getBooleanValue(equipmentProperty[loggedHeader]);
                                        
                                        var validationResult;
                                        
                                        baseType = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].ConvertBaseTypeToFriendlyName({
                                          baseType: baseType
                                        });
                                        
                                        var valueName = {
                                              name: thingName
                                        };
                                        var assetRow = equipmentInformation.Find(valueName);
                                        
                                        var typeHeader = generalInformationDataShapeFields[1];
                                        var thingType = assetRow[typeHeader];
                                        
                                        if (baseType == undefined || !isBaseTypeSupported(baseType)) {
                                          validationResult = me.GenerateReportForEquipment({
                                            operation: constants.invalid
                                          });
                                        
                                          logger.warn("Import Validation Process: [Properties Tab] [Equipment Name: " + thingName + "][Name: " + name + "] Invalid reason: Base Type ["+baseType+"] is not supported");
                                        } else if (isBaseTypeDifferent(thingName, name, baseType, thingType)) {
                                          validationResult = me.GenerateReportForEquipment({
                                            operation: constants.invalid
                                          });
                                        
                                          logger.warn("Import Validation Process: [Properties Tab] [Equipment Name: " + thingName + "][Name: " + name + "] Invalid reason: Changing Base Type is not supported");
                                        } else if (logged == null) {
                                          validationResult = me.GenerateReportForEquipment({
                                            operation: constants.invalid
                                          });
                                        
                                          logger.warn("Import Validation Process: [Properties Tab] [Equipment Name: " + thingName + "][Name: " + name + "] Invalid reason: Invalid Logged value");
                                        } else {
                                          value = validateAndParseValue(baseType, value);
                                        
                                          if (value == null || (baseType === 'JSON' && !isNaN(value))) {
                                            validationResult = me.GenerateReportForEquipment({
                                              operation: constants.invalid
                                            });
                                        
                                            logger.warn("Import Validation Process: [Properties Tab] [Equipment Name: " + thingName + "][Name: " + name + "] Invalid reason: Value is not correct for given Base Type [" + baseType + "]");
                                          } else {
                                        
                                            var thingExists = Things[thingName];
                                        
                                            if (thingExists) {
                                        
                                              if (checkIfPropertyExists(thingName, name)) {
                                                var updated = false;
                                        
                                                var properties = Things[thingName].GetPropertyValues();
                                        
                                                // For non internal properties insert space as default value
                                                if (baseType === 'String' && !isPropertyInherited(name, thingType) && value === "") {
                                                  value = " ";
                                                }
                                        
                                                // Check if value is different
                                                if (baseType === 'JSON' && !compareJSON(JSON.parse(properties[name]), value)) {
                                                  updated = true;
                                                } else if (baseType === 'DateTime' && (getDateTimeNumber(properties[name]) !== getDateTimeNumber(value))) {
                                                  updated = true;
                                                } else if (baseType !== 'JSON' && baseType !== 'DateTime' && properties[name] != value) {
                                                  updated = true;
                                                } else if (!isPropertyInherited(name, thingType)) {
                                                  // Check if property isn't inherited from ThingShapes and if logged is different
                                                  var isLogged = Things[thingName].GetEffectivePropertyLogging({
                                                    propertyName: name
                                                  });
                                                  if (isLogged != logged) {
                                                    updated = true;
                                                  }
                                                }
                                        
                                        
                                                if (updated) {
                                                  validationResult = me.GenerateReportForEquipment({
                                                    operation: constants.updates
                                                  });
                                                } else {
                                                  validationResult = me.GenerateReportForEquipment({
                                                    operation: constants.exists
                                                  });
                                                }
                                              } else {
                                                validationResult = me.GenerateReportForEquipment({
                                                  operation: constants.creates
                                                });
                                              }
                                        
                                            } else {
                                              var propertyInherited = isPropertyInherited(name, thingType);
                                        
                                              // Check if property is inherited from ThingShapes and if it's supported
                                              if (propertyInherited) {
                                                validationResult = me.GenerateReportForEquipment({
                                                  operation: constants.updates
                                                });
                                              } else if (!propertyInherited) {
                                                validationResult = me.GenerateReportForEquipment({
                                                  operation: constants.creates
                                                });
                                              } else {
                                                validationResult = me.GenerateReportForEquipment({
                                                  operation: constants.invalid
                                                });
                                        
                                                logger.warn("Import Validation Process: [Properties Tab] [Equipment Name: " + thingName + " Name: " + name + "] Invalid reason: Property is inherited but not supported");
                                              }
                                            }
                                          }
                                        }
                                        
                                        var result = validationResult;
                                        ]]>
                                        </code>
                                    </Row>
                                </Rows>
                            </ConfigurationTable>
                        </ConfigurationTables>
                    </ServiceImplementation>
                    <ServiceImplementation
                     description=""
                     handlerName="Script"
                     name="ValidatePropertiesTab">
                        <ConfigurationTables>
                            <ConfigurationTable
                             description=""
                             isMultiRow="false"
                             name="Script"
                             ordinal="0">
                                <DataShape>
                                    <FieldDefinitions>
                                        <FieldDefinition
                                         baseType="STRING"
                                         description="code"
                                         name="code"
                                         ordinal="0"></FieldDefinition>
                                    </FieldDefinitions>
                                </DataShape>
                                <Rows>
                                    <Row>
                                        <code>
                                        <![CDATA[
                                        function isValidPropertyName(name) {
                                            var ILLEGAL_CHARS = /[|\[\].,\/\\#+!%^&*;:{}<>=`~()?'"\s]/;
                                            var START_WITH_NUMBER = /^[\d]/;
                                            var START_WITH_EXCLUSIONS = /^[-+\s]/;
                                        
                                            var result = {
                                                success: true
                                            };
                                        
                                            if (name === null || name === undefined || name === '') {
                                                result.success = false;
                                                result.error = 'EMPTY';
                                            } else if (name.match(START_WITH_EXCLUSIONS)) {
                                                result.success = false;
                                                result.error = 'START_WITH_EXCLUSIONS';
                                            } else if (name.match(ILLEGAL_CHARS)) {
                                                result.success = false;
                                                result.error = 'ILLEGAL_CHARS';
                                            } else if (name.match(START_WITH_NUMBER)) {
                                                result.success = false;
                                                result.error = 'START_WITH_NUMBER';
                                            }
                                        
                                            return result;
                                        }
                                        
                                        function createReportTableWithDefaultValues(dataShape) {
                                          var infoTableDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                            dataShapeName: dataShape
                                          })["array"];
                                        
                                          var row = {};
                                          for (var i = 1; i < infoTableDataShapeFields.length; i++) {
                                            row[infoTableDataShapeFields[i]] = 0;
                                          }
                                        
                                          var reportInfoTable = Resources["InfoTableFunctions"].CreateInfoTableFromDataShape({
                                            infoTableName: "reportInfoTable",
                                            dataShapeName: dataShape
                                          });
                                        
                                          reportInfoTable.AddRow(row);
                                        
                                          return reportInfoTable;
                                        }
                                        
                                        function addValuesToReport(params) {
                                          var infoTableDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                            dataShapeName: params.dataShape
                                          })["array"];
                                        
                                          for (var i = 1; i < infoTableDataShapeFields.length; i++) {
                                            params.reportInfoTable.getRow(0)[infoTableDataShapeFields[i]] += params.sourceInfoTable.getRow(0)[infoTableDataShapeFields[i]];
                                          }
                                        
                                          return params.reportInfoTable;
                                        }
                                        
                                        function checkIfEquipmentIsValid(report) {
                                          var reportDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                            dataShapeName: constants.importReportDataShape
                                          })["array"];
                                        
                                          var row = report.getRow(0);
                                        
                                          var validHeader = reportDataShapeFields[2];
                                        
                                          return row[validHeader] === constants.isValid; // checks if Valid == 1
                                        }
                                        
                                        /**
                                         * Function responsible for setting correct report value depending on equipment validation
                                         * @param reportInfoTable with current report data
                                         * @param infoTableDataShapeFields Array with DataShape field names
                                         * @param operation specifies if equipment will be created, updated or it's already exists
                                         * @returns InfoTable with filled proper values for provided operation
                                         */
                                        function markEquipment(reportInfoTable, infoTableDataShapeFields, operation) {
                                          var total = infoTableDataShapeFields[1];
                                          var valid = infoTableDataShapeFields[2];
                                          var invalid = infoTableDataShapeFields[3];
                                          var exists = infoTableDataShapeFields[4];
                                          var creates = infoTableDataShapeFields[5];
                                          var updates = infoTableDataShapeFields[6];
                                        
                                          reportInfoTable.getRow(0)[total]++;
                                          if (operation == constants.creates) {
                                            reportInfoTable.getRow(0)[valid]++;
                                            reportInfoTable.getRow(0)[creates]++;
                                          } else if (operation == constants.exists) {
                                            reportInfoTable.getRow(0)[valid]++;
                                            reportInfoTable.getRow(0)[exists]++;
                                          } else if (operation == constants.updates) {
                                            reportInfoTable.getRow(0)[valid]++;
                                            reportInfoTable.getRow(0)[updates]++;
                                          } else {
                                            reportInfoTable.getRow(0)[invalid]++;
                                          }
                                        
                                          return reportInfoTable;
                                        }
                                        
                                        function isRowDuplicate(thingNameHeader, header, row, validatedRows) {
                                          var thingName = row[thingNameHeader];
                                          var value = row[header];
                                        
                                          var objectToFind = {};
                                          objectToFind[thingNameHeader] = thingName;
                                          objectToFind[header] = value;
                                        
                                          var duplicate = validatedRows.Find(objectToFind);
                                        
                                          return duplicate;
                                        }
                                        
                                        function isRowDuplicateForTag(thingNameHeader, thingHeader, propertyHeader, row, validatedRows) {
                                          var thingName = row[thingNameHeader];
                                          var propertyValue = row[propertyHeader];
                                          var thingValue = row[thingHeader];
                                        
                                          var objectToFind = {};
                                          objectToFind[thingNameHeader] = thingName;
                                          objectToFind[propertyHeader] = propertyValue;
                                          objectToFind[thingHeader] = thingValue;
                                        
                                          var duplicate = validatedRows.Find(objectToFind);
                                        
                                          return duplicate;
                                        }
                                        
                                        function getPropertyBinding(equipmentName, name) {
                                          var thing = Things[equipmentName];
                                        
                                          var localPropertyBinding = thing.GetEffectiveLocalPropertyBinding({
                                            propertyName: name
                                          });
                                          if (localPropertyBinding && localPropertyBinding[constants.rows].length > 0) {
                                            return constants.locallyBound;
                                          }
                                        
                                          try {
                                            var remotePropertyBinding = thing.GetRemotePropertyBinding({
                                              propertyName: name
                                            });
                                            if (remotePropertyBinding && remotePropertyBinding[constants.rows].length > 0) {
                                              return constants.remotelyBound;
                                            }
                                          } catch (err) {
                                            logger.trace("Property " + name + " is not remotely bound");
                                          }
                                        
                                          return constants.noneBound;
                                        }
                                        
                                        
                                        var constants = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetImportExportConstants();
                                        
                                        var importExportDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.importExportDataShape
                                        })["array"];
                                        var generalInformationDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.equipmentGeneralInformationDataShape
                                        })["array"];
                                        var propertiesDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.equipmentPropertiesDataShape
                                        })["array"];
                                        var reportDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.importReportDataShape
                                        })["array"];
                                        var validationResultDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.validationResultDataShape
                                        })["array"];
                                        
                                        // Define constants for headers
                                        var generalInformationHeader = importExportDataShapeFields[2];
                                        var propertiesHeader = importExportDataShapeFields[3];
                                        
                                        var typeHeader = generalInformationDataShapeFields[1];
                                        
                                        var thingNameHeader = propertiesDataShapeFields[0];
                                        var nameHeader = propertiesDataShapeFields[1];
                                        var bindingHeader = propertiesDataShapeFields[2];
                                        var baseTypeHeader = propertiesDataShapeFields[5];
                                        var propertyHeader = propertiesDataShapeFields[9];
                                        var thingHeader = propertiesDataShapeFields[8];
                                        
                                        var reportHeader = validationResultDataShapeFields[0];
                                        var propertiesResultHeader = validationResultDataShapeFields[3];
                                        
                                        var reportInfoTable = createReportTableWithDefaultValues(constants.importReportDataShape);
                                        
                                        var propertiesInfoTable = Resources["InfoTableFunctions"].CreateInfoTableFromDataShape({
                                          infoTableName: "propertiesInfoTable",
                                          dataShapeName: constants.equipmentPropertiesDataShape
                                        });
                                        
                                        var validatedInfoTable = Resources["InfoTableFunctions"].CreateInfoTableFromDataShape({
                                          infoTableName: "validatedInfoTable",
                                          dataShapeName: constants.validationResultDataShape
                                        });
                                        
                                        var equipmentInformationInfoTable = parsedInfoTable[generalInformationHeader];
                                        var equipmentPropertyInfoTable = parsedInfoTable[propertiesHeader];
                                        
                                        function isValidTimeFormat(timeString, checkZeroValue) {
                                          var valid = timeString.match(/^([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$/) && !(checkZeroValue && timeString.match(/^0?(0:00)$/));
                                          return valid;
                                        }
                                        
                                        function isValidDuration(name) {
                                            var startTimeValue;
                                            var durationTimeValue;
                                        
                                            for (var i = 0; i < equipmentPropertyInfoTable.rows.length; i++) {
                                                var row = equipmentPropertyInfoTable.rows[i];
                                        
                                                if (row && row.equipmentName === name) {
                                                    if (row.name === "shiftStartTime") {
                                                        startTimeValue = row.value;
                                                    }
                                        
                                                    if (row.name === "shiftDuration") {
                                                        durationTimeValue = row.value;
                                                    }
                                        
                                                    //if both require properties found ,break
                                                    if (startTimeValue !== undefined && durationTimeValue !== undefined) {
                                                        break;
                                                    }
                                                }
                                            }
                                        
                                            if (startTimeValue === undefined || durationTimeValue === undefined) {
                                                logger.warn("Import Validation Process : shiftStartTime or shiftDuration is missing for "+name);
                                                return false;
                                            }
                                        
                                        
                                            if (!isValidTimeFormat(startTimeValue, false)) {
                                                logger.warn("Import Validation Process : Start Time [" + startTimeValue + "] must be in the format HH:MM. It is invalid for property name [" + name + "]");
                                                return false;
                                            } else if (!isValidTimeFormat(durationTimeValue, true)) {
                                                logger.warn("Import Validation Process : Duration [" + durationTimeValue + "] must be in the format HH:MM and cannot be 00:00. It is invalid for property name [" + name + "]");
                                                return false;
                                            } else {
                                                var startTimeArray = startTimeValue.split(":");
                                                var durationTimeArray = durationTimeValue.split(":");
                                        
                                                var startTime = new Date(new Date().setHours(startTimeArray[0])).setMinutes(startTimeArray[1]);
                                                //Add hours
                                                var totalDurationWithHours = dateAddHours(startTime, durationTimeArray[0]);
                                                //Add minutes
                                                var finalTotalDuration = dateAddMinutes(totalDurationWithHours, durationTimeArray[1]);
                                        
                                                if ((dateDayOfWeek(finalTotalDuration) - dateDayOfWeek(startTime)) !== 0) {
                                                    logger.warn("Import Validation Process : Planned Operation Time is designed to fall within a single calendar day. It is invalid for " + name);
                                                    return false;
                                                } else {
                                                    return true;
                                                }
                                            }
                                        
                                        }
                                        
                                        function equalsIgnoreCase(value1, value2) {
                                          if (value1 == null && value2 == null) {
                                            return true;
                                          }
                                          if (value1 == null || value2 == null) {
                                            return false;
                                          }
                                          return value1.toUpperCase() === value2.toUpperCase();
                                        }
                                        
                                        if (equipmentInformationInfoTable == null || equipmentPropertyInfoTable == null) {
                                          logger.warn("Import Validation Process: Invalid reason: General Information Tab or Properties tab are empty");
                                        } else {
                                        
                                          for (var i = 0; i < equipmentPropertyInfoTable.rows.length; i++) {
                                            var row = equipmentPropertyInfoTable.getRow(i);
                                            var rowNum = i + 2;
                                        
                                            var name = row[thingNameHeader];
                                            var propertyName = row[nameHeader];
                                            var binding = row[bindingHeader];
                                            var baseType = row[baseTypeHeader];
                                            var property = row[propertyHeader];
                                            var thing = row[thingHeader];
                                        
                                            var valueName = {
                                              name: name
                                            };
                                            var assetRow = equipmentInformationInfoTable.Find(valueName);
                                            var duplicateRow = isRowDuplicate(thingNameHeader, nameHeader, row, propertiesInfoTable);
                                            var duplicatePropertyTag = isRowDuplicateForTag(thingNameHeader, thingHeader,propertyHeader, row, propertiesInfoTable);
                                        
                                            // Check if equipment is defined in General Information tab
                                            if (assetRow === null || assetRow["name"] !== name) {
                                              reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.invalid);
                                        
                                              logger.warn("Import Validation Process: [Properties Tab] [Row number: " + rowNum + "] [Equipment Name: " + name + "][Name: " + propertyName + "] Invalid reason: Equipment is not defined in General Information Tab");
                                        
                                              continue;
                                            }
                                        
                                            // Check if Name, Binding or BaseType column is empty
                                            if (propertyName == null || binding == null || baseType == null) {
                                              reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.invalid);
                                        
                                              var missingField = "";
                                              if (propertyName == null) {
                                                missingField = "Name";
                                              } else if (binding == null) {
                                                missingField = "Binding";
                                              } else if (baseType == null) {
                                                missingField = "Base Type";
                                              }
                                        
                                              logger.warn("Import Validation Process: [Properties Tab] [Row number: " + rowNum + "] [Equipment Name: " + name + "][Name: " + propertyName + "] Invalid reason: " + missingField + " is missing");
                                        
                                              continue;
                                            }
                                        
                                            var isNameValid = isValidPropertyName(propertyName);
                                        
                                            // Check if Name meet naming rules
                                            if (!isNameValid.success) {
                                              reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.invalid);
                                        
                                              logger.warn("Import Validation Process: [Properties Tab] [Row number: " + rowNum + "] [Equipment Name: " + name + "][Name: " + propertyName + "] Invalid reason: Name is not valid. Reason [" + isNameValid.error + "]");
                                        
                                              continue;
                                            }
                                        
                                            // Check if there are duplicates
                                            if (duplicateRow != null) {
                                              reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.invalid);
                                        
                                              logger.warn("Import Validation Process: [Properties Tab] [Row number: " + rowNum + "] [Equipment Name: " + name + "][Name: " + propertyName + "] Invalid reason: Duplicated row");
                                        
                                              continue;
                                            }
                                        
                                            var thingExists = Resources["PTC.Factory.CommonUtilities"].DoesThingExists({
                                              thingName: name
                                            });
                                        
                                            // Check if binding is different than on existing thing
                                            if (thingExists && Things[name][propertyName] != undefined && !equalsIgnoreCase(getPropertyBinding(name, propertyName), binding)) {
                                              reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.invalid);
                                        
                                              logger.warn("Import Validation Process: [Properties Tab] [Row number: " + rowNum + "] [Equipment Name: " + name + "][Name: " + propertyName + "] Invalid reason: Property on equipment has different binding");
                                        
                                              continue;
                                            }
                                        
                                            // Check if there is more binding to same tag
                                            if (equalsIgnoreCase(binding, constants.locallyBound) && duplicatePropertyTag != null) {
                                              reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.invalid);
                                        
                                              logger.warn("Import Validation Process: [Properties Tab] [Row number: " + rowNum + "] [Equipment Name: " + name + "][Name: " + propertyName + "] Invalid reason: More than one binding to: thing: " + thing +" and property: "+property);
                                        
                                              continue;
                                            }
                                            if (propertyName.match(/^(shiftStartTime|shiftDuration)$/) && !isValidDuration(name)) {
                                        
                                              reportInfoTable = markEquipment(reportInfoTable, reportDataShapeFields, constants.invalid);
                                        
                                              logger.warn("Import Validation Process: [Properties Tab] [Row number: " + rowNum + "] [Equipment Name: " + name + "][Name: " + propertyName + "] Invalid reason: time format or duration is not valid");
                                        
                                              continue;
                                            }
                                            var propertyRowInfoTable = Resources["InfoTableFunctions"].CreateInfoTableFromDataShape({
                                              infoTableName: "rowInfoTable",
                                              dataShapeName: constants.equipmentPropertiesDataShape
                                            });
                                            propertyRowInfoTable.AddRow(row);
                                        
                                            var propertyInformationInfoTable = Resources["InfoTableFunctions"].CreateInfoTableFromDataShape({
                                              infoTableName: "rowInfoTable",
                                              dataShapeName: constants.importExportDataShape
                                            });
                                            var propertyRow = {};
                                            propertyRow[generalInformationHeader] = equipmentInformationInfoTable;
                                            propertyRow[propertiesHeader] = propertyRowInfoTable;
                                            propertyInformationInfoTable.AddRow(propertyRow);
                                        
                                            var validatePropertyResult = me.ValidateProperty({
                                              parsedInfoTable: propertyInformationInfoTable /* INFOTABLE */
                                            });
                                        
                                            var params = {
                                              reportInfoTable: reportInfoTable,
                                              sourceInfoTable: validatePropertyResult,
                                              dataShape: constants.importReportDataShape
                                            };
                                            reportInfoTable = addValuesToReport(params);
                                        
                                            if (checkIfEquipmentIsValid(validatePropertyResult)) {
                                              propertiesInfoTable.AddRow(row);
                                            }
                                          }
                                        }
                                        
                                        var row = {};
                                        row[reportHeader] = reportInfoTable;
                                        row[propertiesResultHeader] = propertiesInfoTable;
                                        validatedInfoTable.AddRow(row);
                                        
                                        var result = validatedInfoTable;
                                        ]]>
                                        </code>
                                    </Row>
                                </Rows>
                            </ConfigurationTable>
                        </ConfigurationTables>
                    </ServiceImplementation>
                    <ServiceImplementation
                     description=""
                     handlerName="Script"
                     name="ValidateProperty">
                        <ConfigurationTables>
                            <ConfigurationTable
                             description=""
                             isMultiRow="false"
                             name="Script"
                             ordinal="0">
                                <DataShape>
                                    <FieldDefinitions>
                                        <FieldDefinition
                                         baseType="STRING"
                                         description="code"
                                         name="code"
                                         ordinal="0"></FieldDefinition>
                                    </FieldDefinitions>
                                </DataShape>
                                <Rows>
                                    <Row>
                                        <code>
                                        <![CDATA[
                                        function equalsIgnoreCase(value1, value2) {
                                          if (value1 == null && value2 == null) {
                                            return true;
                                          }
                                          if (value1 == null || value2 == null) {
                                            return false;
                                          }
                                          return value1.toUpperCase() === value2.toUpperCase();
                                        }
                                        
                                        var constants = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetImportExportConstants();
                                        
                                        var importExportDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.importExportDataShape
                                        })["array"];
                                        var propertiesDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.equipmentPropertiesDataShape
                                        })["array"];
                                        
                                        // Define constants for headers
                                        var propertiesHeader = importExportDataShapeFields[3];
                                        
                                        var equipmentNameHeader = propertiesDataShapeFields[0];
                                        var nameHeader = propertiesDataShapeFields[1];
                                        var bindingHeader = propertiesDataShapeFields[2];
                                        
                                        var equipmentProperty = parsedInfoTable[propertiesHeader];
                                        
                                        var equipmentName = equipmentProperty[equipmentNameHeader];
                                        var name = equipmentProperty[nameHeader];
                                        var binding = equipmentProperty[bindingHeader];
                                        
                                        var validationResult;
                                        
                                        if (equalsIgnoreCase(binding, constants.noneBound)) {
                                          validationResult = me.ValidateNoneBoundProperty({
                                            parsedInfoTable: parsedInfoTable
                                          });
                                        } else if (equalsIgnoreCase(binding, constants.locallyBound)) {
                                          validationResult = me.ValidateLocallyBoundProperty({
                                            parsedInfoTable: parsedInfoTable
                                          });
                                        } else if (equalsIgnoreCase(binding, constants.remotelyBound)) {
                                          validationResult = me.ValidateRemotelyBoundProperty({
                                            parsedInfoTable: parsedInfoTable
                                          });
                                        } else {
                                          validationResult = me.GenerateReportForEquipment({
                                            operation: constants.invalid
                                          });
                                        
                                          logger.warn("Import Validation Process: [Properties Tab] [Equipment Name: " + equipmentName + "][Name: " + name + "] Invalid reason: Binding is not valid");
                                        }
                                        
                                        var result = validationResult;
                                        ]]>
                                        </code>
                                    </Row>
                                </Rows>
                            </ConfigurationTable>
                        </ConfigurationTables>
                    </ServiceImplementation>
                    <ServiceImplementation
                     description=""
                     handlerName="Script"
                     name="ValidateRemotelyBoundProperty">
                        <ConfigurationTables>
                            <ConfigurationTable
                             description=""
                             isMultiRow="false"
                             name="Script"
                             ordinal="0">
                                <DataShape>
                                    <FieldDefinitions>
                                        <FieldDefinition
                                         baseType="STRING"
                                         description="code"
                                         name="code"
                                         ordinal="0"></FieldDefinition>
                                    </FieldDefinitions>
                                </DataShape>
                                <Rows>
                                    <Row>
                                        <code>
                                        <![CDATA[
                                        function getNullSafeString(value) {
                                          return (value === null || value === undefined) ? "" : value;
                                        }
                                        
                                        function getNullSafeNumber(value) {
                                          return Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetNullSafeNumber({
                                            value: value /* BOOLEAN */
                                          });
                                        }
                                        
                                        function getBooleanValue(value) {
                                          return Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetBooleanValue({
                                            defaultValue: true /* BOOLEAN */ ,
                                            value: value /* STRING */ ,
                                            invalidValue: null /* STRING */
                                          });
                                        }
                                        
                                        function isBaseTypeSupported(baseType) {
                                          var supportedBaseTypes = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetImportSupportedBaseTypes()["array"];
                                        
                                          return supportedBaseTypes.indexOf(baseType) > -1;
                                        }
                                        
                                        function isPushTypeAllowed(pushType) {
                                          var allowedTypes = constants.allowedPushTypes;
                                          return allowedTypes.indexOf(pushType) > -1;
                                        }
                                        
                                        function isTimeoutAllowed(timeoutOption) {
                                          var allowedTimeoutOptions = constants.allowedTimeoutOptions;
                                          return allowedTimeoutOptions.indexOf(timeoutOption) > -1;
                                        }
                                        
                                        /**
                                         * Checks if property already exists on given Thing
                                         *
                                         * @param thingName Name of the thing that has property
                                         * @param propertyName Name of the property that needs to be checked
                                         */
                                        function checkIfPropertyExists(thingName, propertyName) {
                                          var propertyExists = (Things[thingName][propertyName] != null);
                                        
                                          return propertyExists;
                                        }
                                        
                                        function isRemotePropertyNameDifferent(remotePropertyName, remotePropertyBindingInfo) {
                                          return remotePropertyName.length > 0 && (remotePropertyName !== remotePropertyBindingInfo.aspects.tagAddress);
                                        }
                                        
                                        function isCacheIntervalDifferent(cacheInterval, thingName, propertyName) {
                                          var cacheTime = Things[thingName].GetMetadataAsJSON().propertyDefinitions[propertyName].aspects.cacheTime;
                                          return cacheInterval != undefined && (cacheInterval !== Number(cacheTime));
                                        }
                                        
                                        function isPushTypeDifferent(pushType, remotePropertyBindingInfo) {
                                          return pushType.length > 0 && (pushType !== remotePropertyBindingInfo.pushType);
                                        }
                                        
                                        function isPushThresholdDifferent(pushThreshold, remotePropertyBindingInfo) {
                                          return pushThreshold != undefined && (pushThreshold !== Number(remotePropertyBindingInfo.pushThreshold));
                                        }
                                        
                                        function isTimeoutDifferent(timeout, timeoutInterval, remotePropertyBindingInfo) {
                                          var currentTimeoutInterval = Number(remotePropertyBindingInfo.timeout);
                                          var currentTimeout = currentTimeoutInterval !== 0 ? constants.customTimeout : constants.useSystemDefault;
                                           return timeout !== currentTimeout || (timeout== constants.customTimeout && currentTimeoutInterval !== timeoutInterval) ;
                                        }
                                        
                                        
                                        function isBaseTypeDifferent(thingName, name, baseType) {
                                            baseType=baseType.toUpperCase();
                                            if (Things[thingName] !== null && checkIfPropertyExists(thingName, name)) {
                                                var propertyDefinition = Things[thingName].GetPropertyDefinition({
                                                    "name": name
                                                });
                                                return propertyDefinition.baseType !== baseType;
                                            }
                                            return false;
                                        }
                                        
                                        
                                        /**
                                         * Checks if Units that is on property Thing is different than in file
                                         *
                                         * @param thingName Name of the Thing
                                         * @param name Name of the property that is on Thing
                                         * @param units Units value from file
                                         */
                                        function isUnitsDifferent(thingName, name, units) {
                                          var thingMetadata = Things[thingName].GetMetadataAsJSON();
                                          return units.length > 0 && thingMetadata.propertyDefinitions[name].aspects.units !== units;
                                        }
                                        
                                        function unitsIsSupportedForBaseType(baseType) {
                                          var unitsSupportedBaseTypes = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetNumberPropertyBaseTypes()["array"];
                                        
                                          return unitsSupportedBaseTypes.indexOf(baseType.toUpperCase()) > -1;
                                        }
                                        
                                        function isPropertyInherited(propertyName, thingType) {
                                          // result: BOOLEAN
                                          var isInherited = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].isPropertyInherited({
                                            propertyName: propertyName /* STRING */ ,
                                            equipmentType: thingType /* STRING */
                                          });
                                          return isInherited;
                                        }
                                        
                                        function isWhenDisconnectedAllowed(whenDisconnected) {
                                          var allowedTypes = constants.allowedWhenDisconnectedTypes;
                                          return allowedTypes.indexOf(whenDisconnected) > -1;
                                        }
                                        
                                        function isIndustrialDataTypeDifferent(industrialDataType, remotePropertyBindingInfo) {
                                          return industrialDataType.length > 0 && (industrialDataType !== remotePropertyBindingInfo.aspects.industrialDataType);
                                        }
                                        
                                        function isTagAddressDifferent(tagAddress, remotePropertyBindingInfo) {
                                          return tagAddress.length > 0 && (tagAddress !== remotePropertyBindingInfo.aspects.tagAddress);
                                        }
                                        
                                        function isScanRateDifferent(scanRate, remotePropertyBindingInfo) {
                                          return scanRate != undefined && (scanRate !== remotePropertyBindingInfo.aspects.scanRate);
                                        }
                                        
                                        function isTagTypeDifferent(tagType, remotePropertyBindingInfo) {
                                          return tagType.length > 0 && (tagType !== remotePropertyBindingInfo.aspects.tagType);
                                        }
                                        
                                        function isSourceDifferent(source, remotePropertyBindingInfo) {
                                          return source.length > 0 && (source !== remotePropertyBindingInfo.aspects.source);
                                        }
                                        
                                        function isDataShapeDifferent(dataShape, remotePropertyBindingInfo) {
                                          return dataShape.length > 0 && (dataShape !== remotePropertyBindingInfo.aspects.dataShape);
                                        }
                                        
                                        function isValidIndustrialDataType(industrialDataType) {
                                          if(industrialDataType === "" || industrialDataType === undefined) {
                                            return true;
                                          } else {
                                          var allowedTypes = constants.allowedIndustrialDataTypes;
                                          return allowedTypes.indexOf(industrialDataType) > -1;
                                          }
                                        }
                                        
                                        var constants = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetImportExportConstants();
                                        
                                        var importExportDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.importExportDataShape
                                        })["array"];
                                        var propertiesDataShapeFields = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetDataShapeFieldNames({
                                          dataShapeName: constants.equipmentPropertiesDataShape
                                        })["array"];
                                        
                                        // Define constants for headers
                                        var propertiesHeader = importExportDataShapeFields[3];
                                        var generalInformationHeader = importExportDataShapeFields[2];
                                        var thingNameHeader = propertiesDataShapeFields[0];
                                        var nameHeader = propertiesDataShapeFields[1];
                                        var baseTypeHeader = propertiesDataShapeFields[5];
                                        var loggedHeader = propertiesDataShapeFields[6];
                                        var remotePropertyNameHeader = propertiesDataShapeFields[10];
                                        var cacheIntervalHeader = propertiesDataShapeFields[11];
                                        var pushTypeHeader = propertiesDataShapeFields[13];
                                        var pushThresholdHeader = propertiesDataShapeFields[14];
                                        var timeoutHeader = propertiesDataShapeFields[24];
                                        var timeoutIntervalHeader = propertiesDataShapeFields[25];
                                        var unitsHeader = propertiesDataShapeFields[16];
                                        var whenDisconnectedHeader = propertiesDataShapeFields[15];
                                        var industrialDataTypeHeader = propertiesDataShapeFields[26];
                                        var tagAddressHeader = propertiesDataShapeFields[27];
                                        var scanRateHeader = propertiesDataShapeFields[28];
                                        var tagTypeHeader = propertiesDataShapeFields[29];
                                        var sourceHeader = propertiesDataShapeFields[30];
                                        var dataShapeHeader = propertiesDataShapeFields[31];
                                        
                                        var equipmentProperty = parsedInfoTable[propertiesHeader];
                                        var generalInformation = parsedInfoTable[generalInformationHeader];
                                        
                                        var thingName = equipmentProperty[thingNameHeader];
                                        var valueName = {
                                              name: thingName
                                         };
                                        var assetRow = generalInformation.Find(valueName);
                                        var equipmentType = getNullSafeString(assetRow[constants.equipmentType]);
                                        var baseThingTemplate = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].GetTemplateByEquipmentType({equipmentType:equipmentType});
                                        var name = equipmentProperty[nameHeader];
                                        var baseType = equipmentProperty[baseTypeHeader];
                                        var logged = getBooleanValue(equipmentProperty[loggedHeader]);
                                        var remotePropertyName = getNullSafeString(equipmentProperty[remotePropertyNameHeader]);
                                        var cacheInterval = getNullSafeNumber(equipmentProperty[cacheIntervalHeader]);
                                        var pushType = getNullSafeString(equipmentProperty[pushTypeHeader]).toUpperCase();
                                        var pushThreshold = getNullSafeNumber(equipmentProperty[pushThresholdHeader]);
                                        var timeout = getNullSafeString(equipmentProperty[timeoutHeader]);
                                        var timeoutInterval = getNullSafeNumber(equipmentProperty[timeoutIntervalHeader]);
                                        var units = getNullSafeString(equipmentProperty[unitsHeader]);
                                        var whenDisconnected = getNullSafeString(equipmentProperty[whenDisconnectedHeader]).toUpperCase();
                                        var industrialDataType = getNullSafeString(equipmentProperty[industrialDataTypeHeader]);
                                        var tagAddress = getNullSafeString(equipmentProperty[tagAddressHeader]);
                                        var scanRate = getNullSafeNumber(equipmentProperty[scanRateHeader]);
                                        var tagType = getNullSafeString(equipmentProperty[tagTypeHeader]);
                                        var source = getNullSafeString(equipmentProperty[sourceHeader]);
                                        var dataShape = getNullSafeString(equipmentProperty[dataShapeHeader]);
                                        
                                        var validationResult;
                                        
                                        baseType = Things["PTC.SCA.SCO.Common.ImportExportEquipmentUtils"].ConvertBaseTypeToFriendlyName({
                                          baseType: baseType
                                        });
                                        var isDerivedFromRequiredTemplate = true;
                                        if (baseThingTemplate.length > 0) {
                                          // Check if Thing Template extends RemoteThing
                                           isDerivedFromRequiredTemplate = ThingTemplates[baseThingTemplate].IsDerivedFromTemplate({
                                            thingTemplateName: "RemoteThing"
                                          });
                                        }
                                        
                                        if (timeout === constants.useSystemDefault) {
                                            timeoutInterval = undefined;
                                        }
                                        
                                        //ignore units for non-numeric props
                                        if (!unitsIsSupportedForBaseType(baseType)) {
                                            units = undefined;
                                        }
                                        
                                        if (whenDisconnected.length === 0 || whenDisconnected.length > 0 && !isWhenDisconnectedAllowed(whenDisconnected)) {
                                          whenDisconnected = 'NONE';
                                        }
                                        
                                        if (!isDerivedFromRequiredTemplate) {
                                          validationResult = me.GenerateReportForEquipment({
                                            operation: constants.invalid
                                          });
                                          logger.warn("Import Validation Process: [Properties Tab] [Equipment Name: " + thingName + "][Name: " + name + "] Invalid reason: Remotely Bound Property is not supported for equipment which does not extends from RemoteThing");
                                        }
                                        else if (baseType == undefined || !isBaseTypeSupported(baseType)) {
                                          validationResult = me.GenerateReportForEquipment({
                                            operation: constants.invalid
                                          });
                                        
                                          logger.warn("Import Validation Process: [Properties Tab] [Equipment Name: " + thingName + "][Name: " + name + "] Invalid reason: Base Type is not supported");
                                        } else if (isBaseTypeDifferent(thingName, name, baseType)) {
                                          validationResult = me.GenerateReportForEquipment({
                                            operation: constants.invalid
                                          });
                                        
                                          logger.warn("Import Validation Process: [Properties Tab] [Equipment Name: " + thingName + "][Name: " + name + "] Invalid reason: Changing Base Type is not supported");
                                        }  else if (logged == null) {
                                          validationResult = me.GenerateReportForEquipment({
                                            operation: constants.invalid
                                          });
                                        
                                          logger.warn("Import Validation Process: [Properties Tab] [Equipment Name: " + thingName + "][Name: " + name + "] Invalid reason: Invalid Logged value");
                                        }  else if (timeout == constants.customTimeout && timeoutInterval === null) {
                                          validationResult = me.GenerateReportForEquipment({
                                            operation: constants.invalid
                                          });
                                        
                                          logger.warn("Import Validation Process: [Properties Tab] [Equipment Name: " + thingName + "][Name: " + name + "] Invalid reason: missing timeout interval");
                                        } else if (timeoutInterval !== null && timeout === "") {
                                          validationResult = me.GenerateReportForEquipment({
                                            operation: constants.invalid
                                          });
                                        
                                          logger.warn("Import Validation Process: [Properties Tab] [Equipment Name: " + thingName + "][Name: " + name + "] Invalid reason: missing timeout");
                                        } else if (industrialDataType !== null && !isValidIndustrialDataType(industrialDataType)) {
                                          validationResult = me.GenerateReportForEquipment({
                                            operation: constants.invalid
                                          });
                                        
                                          logger.warn("Import Validation Process: [Properties Tab] [Equipment Name: " + thingName + "][Name: " + name + "] Invalid reason: Invalid Industrial Data Type");
                                        } else if (scanRate !== null && scanRate < 0) {
                                          validationResult = me.GenerateReportForEquipment({
                                            operation: constants.invalid
                                          });
                                        
                                          logger.warn("Import Validation Process: [Properties Tab] [Equipment Name: " + thingName + "][Name: " + name + "] Invalid reason: Invalid Scan Rate");
                                        } else {
                                        
                                          if (!isPushTypeAllowed(pushType)) {
                                            pushType = 'VALUE';
                                          }
                                          
                                          if (!isTimeoutAllowed(timeout)) {
                                            timeout = constants.useSystemDefault;    
                                            timeoutInterval = undefined;
                                          }
                                        
                                          var thingExists = Things[thingName];
                                        
                                          //thingworx stores cacheInterval in milliseconds but import excel sheet expects as seconds.
                                          if (cacheInterval !== null) {
                                             cacheInterval = cacheInterval*1000;
                                          }
                                          
                                          if (thingExists) {
                                        
                                            if (checkIfPropertyExists(thingName, name)) {
                                              var updated = false;
                                        
                                              var isLogged = Things[thingName].GetEffectivePropertyLogging({
                                                propertyName: name
                                              });
                                        
                                              if (isLogged != logged) {
                                                updated = true;
                                              }
                                        
                                              var remotePropertyBindingInfo = Things[thingName].GetRemotePropertyBinding({
                                                propertyName: name
                                              });
                                        
                                              if (isRemotePropertyNameDifferent(remotePropertyName, remotePropertyBindingInfo)) {
                                                updated = true;
                                              } else if (isCacheIntervalDifferent(cacheInterval, thingName, name)) {
                                                updated = true;
                                              } else if (isPushTypeDifferent(pushType, remotePropertyBindingInfo)) {
                                                updated = true;
                                              } else if (isPushThresholdDifferent(pushThreshold, remotePropertyBindingInfo)) {
                                                updated = true;
                                              } else if (isTimeoutDifferent(timeout, timeoutInterval, remotePropertyBindingInfo)) {
                                                updated = true;
                                              } else if (unitsIsSupportedForBaseType(baseType) && isUnitsDifferent(thingName, name, units)) {
                                                // Check if units value is different
                                                updated = true;
                                              } else if (isIndustrialDataTypeDifferent(industrialDataType, remotePropertyBindingInfo)) {
                                                updated = true;
                                              } else if (isTagAddressDifferent(tagAddress, remotePropertyBindingInfo)) {
                                                updated = true;
                                              } else if (isScanRateDifferent(scanRate, remotePropertyBindingInfo)) {
                                                updated = true;
                                              } else if (isTagTypeDifferent(tagType, remotePropertyBindingInfo)) {
                                                updated = true;
                                              } else if (isSourceDifferent(source, remotePropertyBindingInfo)) {
                                                updated = true;
                                              } else if (isDataShapeDifferent(dataShape, remotePropertyBindingInfo)) {
                                                updated = true;
                                              }
                                        
                                              if (updated) {
                                                validationResult = me.GenerateReportForEquipment({
                                                  operation: constants.updates
                                                });
                                              } else {
                                                validationResult = me.GenerateReportForEquipment({
                                                  operation: constants.exists
                                                });
                                              }
                                            } else {
                                              validationResult = me.GenerateReportForEquipment({
                                                operation: constants.creates
                                              });
                                            }
                                        
                                          } else {
                                            var propertyInherited = isPropertyInherited(name, equipmentType);
                                            if (propertyInherited) {
                                              validationResult = me.GenerateReportForEquipment({
                                                operation: constants.updates
                                              });
                                            } else {
                                              validationResult = me.GenerateReportForEquipment({
                                                operation: constants.creates
                                              });
                                            }
                                          }
                                        }
                                        
                                        var result = validationResult;
                                        ]]>
                                        </code>
                                    </Row>
                                </Rows>
                            </ConfigurationTable>
                        </ConfigurationTables>
                    </ServiceImplementation>
                </ServiceImplementations>
                <Subscriptions></Subscriptions>
            </ThingShape>
            <ImplementedShapes></ImplementedShapes>
            <SharedConfigurationTables></SharedConfigurationTables>
            <InstanceDesignTimePermissions>
                <Create></Create>
                <Read></Read>
                <Update></Update>
                <Delete></Delete>
                <Metadata></Metadata>
            </InstanceDesignTimePermissions>
            <InstanceRunTimePermissions></InstanceRunTimePermissions>
            <InstanceVisibilityPermissions>
                <Visibility></Visibility>
            </InstanceVisibilityPermissions>
        </ThingTemplate>
    </ThingTemplates>
</Entities>
